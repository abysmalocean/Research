C*
C*    NOTE: IN THE WRITEUP THE I-TH CLUSTER MEANS A PARTICLE IN THE
C*          DISCRETE REGIME CONTAINING I MONOMERS.  THE I-TH MULTIPLET
C*          IS THE I-TH GRID POINT, WHICH IS SPECIFIED BY THE NUMBER OF
C*          MONOMERS CONTAINED IN THE PARTICLE.
C*
C*    R.J.=RIGHT JUSTIFIED INTEGER
C*    GDE=GENERAL DYNAMIC EQUATION
C*    DC GDE=DISCRETE-CONTINUOUS GENERAL DYNAMIC EQUATION
C*
C*                  FIRST CARD OF INPUT
C*
C*    IN COLUMNS 1-2 THE NUMBER OF CASES TO BE COMPUTED    R.J.
C*    IF A BLANK CARD IS USED ONE CASE WILL BE ASSUMED.
C*
C*
C*    FOR EACH CASE THE FOLLOWING SET OF CARDS MUST FOLLOW.  UNLESS
C*    SPECIFIED AS RIGHT JUSTIFIED (R.J.) INTEGER, ALL INPUT DATA IS TO
C*    BE IN REAL FORMAT.
C*
C*                  FIRST CARD/CASE
C*
C*    COLUMNS
C*     1-40    TITLE TO BE PRINTED AS A HEADING FOR THIS CASE
C*    41-50    SMALLEST PARTICLE SIZE  (IF THE DC GDE IS USED THIS IS
C                THE MONOMER SIZE. THE PROGRAM AUTOMATICALLY DETERMINES
C*               THE SMALLEST SIZE IN THE CONTINUOUS REGIME)
C*    51-60    LARGEST PARTICLE SIZE
C*    61-70    RELATIVE INTEGRATION ERROR
C*    71-80    ABSOLUTE INTEGRATION ERROR
C*
C*                  SECOND CARD/CASE
C*
C*     1- 2    NUMBER OF GRID POINTS   (10-40)             R.J.
C*     3- 4    MAXIMUM NUMBER OF GRID POINTS  (10-40)      R.J.
C*     5- 6    NUMBER OF DISCRETE SIZES (0,2-20)           R.J.
C*               (IF SET TO ZERO THE CONTINUOUS GDE IS ASSUMED)
C*     7- 8    NUMBER OF DISCRETE MULTIPLETS IN THE CONTINUOUS REGIME
C*               (0,2-20)                                  R.J.
C*               (MUST BE SET TO ZERO FOR THE CONTINUOUS GDE)
C*     9-10    NUMBER OF OUTPUTS (1-16)                    R.J.
C*    11-12    THE OUTPUT TIME NUMBER WHEN THE PROGRAM IS TO SWITCH
C*             INTERPOLATION METHODS.  FOR EXAMPLE, IF 5 OUTPUT TIMES
C*             ARE GIVEN AS 0.0,60.,300.,600., AND 1200. SECONDS, THEN
C*             A 2 WOULD RESULT IN THE PROGRAM SWITHCING FROM THE
C*             INITIALLY SPECIFIED INTERPOLATION METHOD TO THE OTHER
C*             ALTERNATIVE IMMEDIATELY AFTER 60. SECONDS OF SIMULATION.
C*             A NUMBER LESS THAN OR EQUAL TO 1 OR GREATER THAN THE
C*             NUMBER OF OUTPUTS WOULD RESULT IN NO CHANGE OF
C*             INTERPOLATING METHODS.                       R.J.
C*    13-14    THE OUTPUT TIME NUMBER WHEN THE PROGRAM IS TO
C*             SWITCH TO THE STEADY STATE APPROXIMATION FOR THE
C*             DISCRETE REGIME.  IF SET TO -1 THE PROGRAM WILL PRINT
C*             THE STEADY STATE CONCENTRATIONS IN ADDITION TO THE
C*             TRANSIENT CONCENTRATIONS.  IF SET TO -2 THE PROGRAM
C*             WILL SWITCH TO THE STEADY STATE APPROXIMATION WHEN
C*             THE SPECIFIED ERROR TOLERANCES ARE MET.  (SET TO
C*             ZERO FOR THE CONTINUOUS GDE)                 R.J.
C*    15-20            *** BLANK ***
C*    21-23    GRID POINT SELECTION
C*               0=PROGRAM WILL SELECT LOGARITHMICALLY SPACED GRID
C*                 IN PARTICLE SIZE
C*               FOR VALUES GREATER THAN OR EQUAL TO ONE, THIS IS THE
C*                 NUMBER OF GRID POINTS TO BE READ IN ASCENDING ORDER.
C*                 FOR NEGATIVE VALUES, READ IN DESCENDING ORDER THE
C*                 ABSOLUTE VALUE NUMBER OF GRID POINTS. THE PROGRAM
C*                 WILL SELECT THE REMAINING GRID POINTS AS
C*                 LOGARITHMICALLY SPACED IN PARTICLE SIZE.  R.J.
C*    24-30            *** BLANK ***
C*       31    NUMBER OF INTERPOLATING POINTS BETWEEN GRID POINTS
C*       32    NUMBER OF CONTINUOUS SOURCE TERMS  (0-3)
C*       33    NUMBER OF CONTINUOUS REMOVAL TERMS (0-3)
C*       34    NUMBER OF DISCRETE SOURCE TERMS    (0-3)
C*       35    NUMBER OF DISCRETE REMOVAL TERMS   (0-3)
C*       36    0=NO CONDENSATION, 1=WITH CONDENSATION
C*       37    INITIAL SPLINE INTERPOLATION METHOD NUMBER
C*               0=CUBIC SPLINES
C*               1=LINEAR SPLINES
C*               2=LOGARITHMIC SPLINES (POWER LAW FIT)
C*       38    CALL SETUP BEFORE INTERPOLATING  (0=NO/1=YES)
C*       39    SPLINE INTERPOLATION METHOD NUMBER FOR SWITHCED METHOD
C*       40    CALL SETUP FOR SWITCHED METHOD  (0=NO/1=YES)
C*       41    TIME DEPENDENT COAGULATION AND EVAPORATION
C*               COEFFICIENTS (0=NO/1=YES)
C*    42-50            *** BLANK ***
C*    51-60    USER DEFINED PARAMETER SWITCHES
C*
C*                  THIRD CARD(S)/CASE
C*
C*    IN FORMAT 8E10.4 THE TIMES FOR WHICH OUTPUT IS DESIRED IN
C*    ASCENDING ORDER. IF THE FIRST OUTPUT TIME IS GREATER
C*    THAN ZERO THE SEVENTH CARD(S)/CASE MUST BE INCLUDED.  THE NUMBER
C*    OF OUTPUT TIMES IS SPECIFIED IN COLUMNS 9-10 OF THE SECOND
C*    CARD/CASE
C*
C*                  FOURTH CARD(S)/CASE
C*
C*    IN FORMAT 16I5 THE DISCRETE MULTIPLET NUMBERS IN ASCENDING
C*    ORDER.  THE FIRST AND LAST GRID POINTS ARE AUTOMATICALLY FIXED AT
C*    THE SMALLEST AND LARGEST PARTICLE SIZE RESPECTIVELY, IN THE
C*    CONTINUOUS REGIME.  THEREFORE THE FIRST MULTIPLET NUMBER GIVEN
C*    MUST BE GREATER THAN OR EQUAL TO THE NUMBER OF DISCRETE SIZES PLUS
C*    TWO. THE MULTIPLET NUMBERS MUST RANGE FROM THE NUMBER OF DISCRETE
C*    SIZES PLUS TWO TO TWICE THE NUMBER OF DISCRETE SIZES. THE LAST
C*    MULTIPLET NUMBER MUST BE EQUAL TO TWICE THE NUMBER OF DISCRETE
C*    SIZES. THE NUMBER OF MULTIPLETS GIVEN SHOULD CORRESPOND TO
C*    COLUMNS 7-8 IN THE SECOND CARD/CASE
C*    (IF NO DISCRETE SIZES ARE USED DO NOT PUT IN ANY CARD)
C*
C*                  FIFTH CARD(S)/CASE
C*
C*    IN FORMAT 8E10.4 THE INITIAL NUMBER CONCENTRATION IN THE
C*    DISCRETE REGIME IN ASCENDING PARTICLE SIZE ORDER. IF THE
C*    STEADY STATE APPROXIMATION IS REQUESTED FOR THE FIRST
C*    OUTPUT TIME (I.E. COLUMNS 13-14 IN THE SECOND CARD/CASE
C*    IS 01), THEN THESE VALUES WILL BE USED AS THE INITIAL
C*    GUESS FOR DETERMINING THE STEADY STATE CONCENTRATIONS
C*    (IF NO DISCRETE SIZES ARE USED DO NOT PUT IN ANY CARD)
C*
C*                  SIXTH CARD(S)/CASE
C*
C*    IN FORMAT 8E10.4 THE PARTICLE SIZES OF THE GRID POINTS IN
C*    ASCENDING OR DESCENDING ORDER AS SPECIFIED IN CARD COLUMNS 21-23
C*    IN THE SECOND CARD/CASE.
C*    THE NUMBER OF GRID POINTS GIVEN MUST BE LESS THAN THE NUMBER OF
C*    GRID POINTS MINUS THE NUMBER OF MULTIPLETS GIVEN MINUS TWO.
C*    FOR THE CONTINUOUS GDE THE FIRST GRID POINT IS AUTOMATICALLY SET
C*    AT THE SMALLEST PARTICLE SIZE.  THEREFORE GRID POINTS ARE READ
C*    IN STARTING WITH THE SECOND ACTUAL GRID POINT. FOR THE DISCRETE -
C*    CONTINUOUS GDE GRID POINTS ARE READ IN STARTING AFTER THE LAST
C*    MULTIPLET SIZE AND SHOULD THEREFORE HAVE A SIZE GREATER THAN
C*    THE MONOMER SIZE TIMES TWICE THE NUMBER OF DISCRETE SIZES. IF
C*    GRID POINTS ARE READ IN DECSENDING ORDER THE FIRST GRID POINT
C*    SIZE READ IN MUST BE LESS THAN THE LARGEST SIZE SPECIFIED IN
C*    COLUMNS 51-60 OF THE FIRST CARD/CASE.
C*    (NOT TO BE USED IF LOGARITHMICALLY SPACED GRID POINTS ARE
C*     REQUESTED, I.E. COLUMNS 21-23 IN THE SECOND CARD/CASE IS ZERO)
C*
C*                    SEVENTH CARD(S)/CASE
C*
C*    IN FORMAT 8E10.4 THE DISTRIBUTION VALUES FOR INITIAL TIMES
C*    GREATER THAN ZERO.  EVEN IF GRID POINTS ARE READ IN
C*    DESCENDING ORDER, THE DISTRIBUTION VALUES ARE READ IS
C*    ASCENDING ORDER. THIS CARD(S) IS REQUIRED ONLY IF THE FIRST
C*    OUTPUT TIME IS GREATER THAN ZERO
C*
C*    TO TRANSFER PARAMETER VALUES TO THE ROUTINES
C*    INSERT THE FOLLOWING: COMMON/AERSL1/IPARM(10)
C*    IF YOU ENCOUNTER ANY TROUBLE USING THE PROGRAM CONTACT
C*                      FRED GELBARD
C*                      DEPT. OF CHEMICAL ENGINEERING
C*                      CALTECH 208-41
C*                      PASADENA,C.A.  91125
C*                      TEL. 213-7956811 EXT 1671 OR EXT 1115
C*----------------------------------------------------------------------
C*
C*          VARIABLES USED BY THE PROGRAM
C*
C*    A(I)=FOR I=1 TO NVAR IT IS THE VALUE OF THE CONTINUOUS
C*      DISTRIBUTION AT THE I-TH GRID POINT.  FOR I=NVAR+1 TO NVART
C*      IT IS THE NUMBER OF PARTICLES AT THE DISCRETE SIZE I-NVAR
C*    ABSERR=ABSOLUTE INTEGRATION ERROR (SEE ODE CODE WRITE UP)
C*    ADIF(I)=THIS ARRAY IS USED TO TRANSFER THE A ARRAY TO THE ODE
C*      PACKAGE.
C*    ASAVE(I)=SAVED A ARRAY FROM LAST OUTPUT TIME
C*    ALGXBA=LN(XB/XA)
C*    ATRY(I)=NEXT ITERATION FOR THE CONCENTRATION OF THE I-TH CLUSTER,
C*      USING THE STEADY STATE APPROXIMATION
C*    BESR(I,J)=COAGULATION COEFFICIENT TIMES THE JACOBIAN FOR THE I-TH
C*      DISCRETE CLUSTER WITH A PARTICLE IN THE CONTINUOUS REGIME SUCH
C*      THAT A PARTICLE AT THE J-TH GRID POINT IS FORMED
C*    BETADC(I,J)=THE COAGULATION COEFFICIENT OF THE I-TH CLUSTER WITH
C*      THE J-TH GRID POINT
C*    BETDSR(I)=STORAGE ARRAY FOR CLUSTER-CLUSTER COAGULATION
C*      COEFFICIENTS
C*    BOTTOM=LOWER LIMIT OF INTEGRATION
C*    DADT(I)=THE DERIVATIVE OF ADIF(I) WITH RESPECT TO TIME
C*    DIAG(I)=DIAGONAL ELEMENTS OF TRI-DIAGONAL MATRIX
C*    DISTD=NUMBER DISTRIBUTION (NUMBER/CC)
C*    DISTS=SURFACE AREA DISTRIBUTION  (SQUARE CM/CC)
C*    DISTV=VOLUME DISTRIBUTION  (CC/CC)
C*    DMEAN=MEAN DIAMETER  (CM)
C*    EVAPR=TOTAL MONOMER EVAPORATION RATE FROM THE CONTINUOUS REGIME
C*    EVPSTR(I)=EVAPORATION COEFFICIENT AT THE I-TH GRID POINT. FOR
C*      I=NVARP2 TO NVART, THIS IS THE EVAPORATION COEFFICIENT OF THE
C*      I-TH CLUSTER
C*    FACT1A(I,J)=THE I-TH QUADRATURE FACTOR FOR THE FIRST TERM OF THE
C*      FIRST COAGULATION INTEGRAL FOR THE J-TH GRID POINT
C*    FACT1B(I,J)=THE I-TH QUADRATURE FACTOR FOR THE SECOND TERM OF THE
C*      FIRST COAGULATION INTEGRAL FOR THE J-TH GRID POINT
C*    FACT2(I,J)=THE I-TH QUADRATURE FACTOR FOR THE SECOND COAGULATION
C*      INTEGRAL FOR THE J-TH GRID POINT. FOR J=NVARP1 TO NVART THIS IS
C*      THE QUADRATURE FACTOR FOR THE SCAVENGING OF THE (J-NVAR)-TH
C*      CLUSTER BY PARTICLES IN THE CONTINUOUS REGIME
C*    FACTE1(I)=THE I-TH QUADRATURE FACTOR FOR THE GAIN OF MONOMER DUE
C*      TO EVAPORATION FROM THE CONTINUOUS REGIME
C*    FACTE3(I)=THE I-TH QUADRATURE FACTOR FOR EVAPORATION FROM THE
C*      CONTINUOUS REGIME TO FORM THE LARGEST DISCRETE PARTICLE
C*    FACTOR(I)=THE I-TH QUADRATURE WEIGHT FACTOR FOR INTEGRATION OVER
C*      THE ENTIRE CONTINUOUS DOMAIN
C*    HEADNG=CHARACTER STRING FOR HEADING
C*    ICASE=THE CASE NUMBER BEING SOLVED
C*    ICONDN=  0=NO CONDNESATION/1=WITH CONDENSATION
C*    IFLAG=FLAG TO ODE, 1 INDICATES THIS IS THE FIRST CALL
C*    IGRID=NUMBER OF GRID POINTS GIVEN
C*    IPARM(I)=THE I-TH USER SUPPLIED PARAMETER
C*    IPRNT=PRINTER LOGICAL UNIT NUMBER
C*    IREAD=CARD READER LOGICAL UNIT NUMBER
C*    ISETSW=OUTPUT NUMBER TO SWITCH INTERPOLATION METHOD
C*    ISETUP=FLAG TO CALL SETUP BEFORE INTERPOLATING (0=NO/1=YES)
C*    ISPLIN=FLAG TO INDICATE  0=CUBIC SPLINE INTERPOLATION
C*                             1=LINEAR SPLINE INTERPOLATION
C*                             2=LOGARITHMIC INTERPOLATION
C*    ISPSWT=FLAG TO CALL SETUP FOR SWITCHED INTERPOLATION METHOD
C*      (0=NO/1=YES)
C*    ISSFLG=STEADY STATE FLAG, 0=DO NOT USE THE STEADY STATE
C*      APPROXIMATION, 1=USE THE STEADY STATE APPROXIMATION FOR THE
C*      DISCRETE REGIME
C*    ISSTAT=OUTPUT NUMBER AT WHICH THE STEADY STATE APPROXIMATION IS
C*      TO BE USED.  IF ZERO DO NOT USE THE S.S. APPROXIMATION.  IF
C*      -1 PRINT S.S. BUT DO NOT USE.  IF -2 SWITCH TO S.S. WHEN
C*      SPECIFIED ERROR TOLERANCES HAVE BEEN MET
C*    ISTOP=ERROR FLAG, 1=ERROR,0=NO ERROR,-1=CORRECTABLE ERROR,CODE
C*            WILL REVERT TO PREVIOUS OUTPUT TIME,-2=PRINT ONLY DISCRETE
C*            REGIME AS DETERMINED FROM THE STEADY STATE APPROXIMATION
C*    ISWTCH=THE OUTPUT NUMBER FOR WHICH THE PROGRAM IS TO
C*      SWITCH INTERPOLATION METHODS
C*    ITIMDP=FLAG FOR TIME DEPENDENT COAGULATION AND EVAPORATION
C*      COEFFICIENTS (0=TIME INDEPENDENT/1=TIME DEPENDENT)
C*    JPRTIM=THE PRINTING DO-LOOP COUNTER
C*    MAXEVP=THE LAST GRID POINT IN THE CONTINUOUS REGIME FOR WHICH
C*      EVAPORATION IS STILL INCLUDED
C*    MAXGDC(I)=MAXIMUM DISCRETE CLUSTER SIZE THAT CAN COAGULATE WITH A
C*      PARTICLE IN THE CONTINUOUS REGIME TO FORM A PARTICLE AT THE I-TH
C*      GRID POINT
C*    MAXSZ=THE LARGEST DISCRETE CLUSTER THAT CAN COAGULATE WITH ANOTHER
C*      DISCRETE CLUSTER TO FROM THE CLUSTER OF INTEREST
C*    MINW=SMALLEST GRID POINT FOR WHICH THE FIRST COAGULATION INTEGRAL
C*      IS TO BE COMPUTED
C*    MXCASE=MAXIMUM NUMBER OF CASES TO SOLVE. WILL DEFAULT TO ONE IF
C*      LESS THAN OR EQUAL TO ZERO
C*    NCREMV=NUMBER OF CONTINUOUS REMOVALS
C*    NCSORC=NUMBER OF CONTINUOUS SOURCES
C*    NDCLS(I)=THE DISCRETE SIZE NUMBER OF THE I-TH GRID POINT GIVEN IN
C*      THE CONTINUOUS REGIME
C*    NDISCR=NUMBER OF DISCRETE SIZES
C*    NDREMV=NUMBER OF DISCRETE REMOVALS
C*    NDSORC=NUMBER OF DISCRETE SOURCES
C*    NMULGV=NUMBER OF DISCRETE MULTIPLETS GIVEN IN THE CONTINUOUS
C*      REGIME
C*    NMULP1=NUMBER OF MULTIPLETS GIVEN PLUS ONE
C*    NMULP2=NUMBER OF MULTIPLETS GIVEN PLUS TWO
C*    NMXVAR=MAXIMUM NUMBER OF GRID POINTS
C*    NPRNT=NUMBER OF OUTPUTS
C*    NPTBET=NUMBER OF INTERPOLATED POINTS BETWEEN GRID POINTS
C*    NQUADP=NUMBER OF QUADRATURE POINTS (MUST BE AN EVEN NUMBER)
C*    NQUAD2=HALF THE NUMBER OF QUADRATURE POINTS
C*    NTROUB=NUMBER OF POINTS AT WHICH DISTRIBUTION IS NEGATIVE
C*    NVAR=NUMBER OF VARIABLES IN THE CONTINUOUS REGIME
C*          (EQUAL TO THE NUMBER OF GRID POINTS)
C*    NVARP1=NVAR+1=NUMBER OF VARIABLES PLUS ONE
C*    NVARP2=NVAR+2=NUMBER OF VARIABLES PLUS TWO
C*    NVART=TOTAL NUMBER OF VARIABLES=NVAR+NDISCR
C*    P(I)=STORAGE ARRAY FOR THE SECOND DERIVATIVE OF M(W,T) WITH
C*      RESPECT TO W AT THE I+1 GRID POINT.  AT THE FIRST AND LAST GRID
C*      POINT THE SECOND DERIVATIVE IS ASSUMED TO BE ZERO.
C*    RELERR=RELATIVE ERROR (SEE ODE CODE WRITE UP)
C*    SCAVNG(I)=SCAVENGING RATE OF THE I-TH CLUSTER
C*    TOTALQ=ARRAY CONTAINING THE FIRST MOMENTS OF AEROSOL ADDED
C*      TO AND REMOVED FROM THE CONTINUOUS REGIME, AND ADDED TO
C*      AND REMOVED FROM THE DISCRETE REGIME FOR EACH MECHANISM,
C*      RESPECTIVELY
C*    TOTNUM=TOTAL NUMBER OF PARTICLES/CC
C*    TOTSUR=TOTAL SURFACE AREA  (SQUARE CM/CC)
C*    TOTVOL=TOTAL VOLUME OF PARTICLES  (CC/CC)
C*    TOUT(I)=THE I-TH OUTPUT TIME
C*    SUB(I)=SUB-DIAGONAL ELEMENTS OF TRI-DIAGONAL MATRIX
C*    SUPER(I)=SUPER-DIAGONAL ELEMENTS OF TRI-DIAGONAL MATRIX
C*    TXA=LN(2)/LN(XB/XA)= THE W SIZE OF A PARTICLE PRODUCED WHEN
C*      TWO OF THE SMALLEST PATICLES OF SIZE W=0 COAGULATE
C*    UPPER=UPPER LIMIT OF INTEGRATION
C*    W(I)=LN(X/XA)/LN(XB/XA) OF THE I-TH GRID POINT
C*    WBET(I)=THE I-TH W VALUE INTERPOLATED BETWEEN TWO GRID POINTS
C*    WD(I,J)=THE W OF A PARTICLE IN THE CONTINUOUS REGIME, SUCH THAT
C*      WHEN IT COAGUALTES WITH THE I-TH DISCRETE CLUSTER A PARTICLE OF
C*      SIZE W(J) IS FORMED
C*    WMZ1(I,J)=THE W SIZE OF A PARTICLE WHICH WHEN IT COAGULATES WITH A
C*      PARTICLE AT THE I-TH QUADRATURE POINT, A PARTICLE AT THE J-TH
C*      GRID POINT IS FORMED
C*    WPLS(I)=THE W SIZE OF THE I-TH GRID POINT PLUS A MONOMER
C*    X(I)=PARTICLE SIZE AT THE I-TH GRID POINT
C*    XA=SIZE OF SMALLEST PARTICLE
C*    XB=SIZE OF LARGEST PARTICLE
C*    XBET=PARTICLE SIZE OF INTERPOLATED POINTS BETWEEN TWO GRID POINTS
C*    XBOXA=XB/XA
C*    XTROUB(I)=PARTICLE SIZE ARRAY AT WHICH DISTRIBUTION IS NEGATIVE
C*    Z(I)=THE W SIZE OF THE I-TH QUADRATURE POINT OVER THE ENTIRE
C*      CONTINUOUS REGIME
C*    ZMASS(I)=THE PARTICLE SIZE AT THE I-TH QUADRATURE POINT
C*    Z1(I,J)=THE I-TH QUADRATURE POINT FOR THE FIRST COAGULATION
C*      INTEGRAL FOR THE J-TH GRID POINT
C*    Z2(I,J)=THE I-TH QUADRATURE POINT FOR THE SECOND COAGUALTION
C*      INTEGRAL FOR THE J-TH GRID POINT
C*----------------------------------------------------------------------
C     PROGRAM AEROSL
C-----------------------------------------------------------------------
C*    THIS IS THE MAIN PROGRAM FOR THE AEROSOL CODE                    *
C
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION WORK(1360),IWORK(5),ASAVE(20)
      CHARACTER*40 FILNAM1,FILNAM2,FILNAM3
      COMMON/AERSL2/A(60),X(60),W(40)
      COMMON/AERSL5/ISAVE,ICONDN,IGRID,IPRNT,IPTIM,IREAD,ISETSW,ISETUP,
     $  ISPSWT,ISPLIN,ISSTAT,ISWTCH,ISSFLG,ITIMDP,NCREMV,NCSORC,
     $  NDCLS(20),NDISCR,NDREMV,NDSORC,NMULP1,NMXVAR,NPRNT,NPTBET,
     $  NQUADP,NVAR,NVART,NVARP1,NVARP2,NVARM1,MAXEVP,MINW
      COMMON/AERSL6/TOUT(16),DUMTIM,XA,XB,XBOXA,ALGXBA,RELERR,ABSERR
      EXTERNAL DIFFUN
C
      PRINT 30
      READ 31,FILNAM1
      PRINT 32
      READ 31,FILNAM2
   30 FORMAT(' ENTER INPUT FILE: ')
   31 FORMAT(A40)
   32 FORMAT(' ENTER OUTPUT FILE: ')
      OPEN(UNIT=1,FILE=FILNAM1,STATUS='OLD')
      OPEN(UNIT=2,FILE=FILNAM2,STATUS='NEW')
      READ(IREAD,1)MAXCAS
    1 FORMAT(I2)
      IF(MAXCAS.LE.0)MAXCAS=1
      WRITE(IPRNT,2)MAXCAS
    2 FORMAT(////52X,17HNUMBER OF CASES =,I3)
C
C        IN THE FOLLOWING DO LOOP TERMINATING WITH STATEMENT NUMBER 10
C        COMPUTE EACH CASE
C
      DO 10 ICASE=1,MAXCAS
C
C        READ AND CHECK INPUT DATA. IF AN INPUT ERROR IS FOUND (I.E.
C        ISTOP=1), SKIP THE CASE. IF NO ERRORS ARE FOUND (I.E. ISTOP=0)
C        CALL THE ROUTINE SETUP IF NEEDED FOR INTERPOLATION AND CONTINUE
C
      CALL INPUT
      IODEPK=0
      TIME=TOUT(1)
      DUMTIM=TIME
      ISTOP=0
      IPTIM=1
      IF(ISETUP.EQ.1)CALL SETUP(ISPLIN,1,NVAR)
      CALL CHECK(ISTOP)
      IF(ISTOP.EQ.1)GO TO 10
      WRITE(IPRNT,20)
   20 FORMAT(//47X,26HNO DATA INPUT ERRORS FOUND)
      IF(ISETUP.EQ.1)CALL SETUP(ISPLIN,1,NVAR)
C
C        CHECK FOR NEGATIVE VALUES OF THE DISTRIBUTION.  IF A NEGATIVE
C        VALUE WAS FOUND AND GRID POINTS WERE ADDED (I.E. ISTOP=-1),
C        RECHECK THE INTERPOLATION SCHEME.  IF A NEGATIVE VALUE WAS
C        FOUND AND NO GRID POINTS WERE ADDED (I.E. ISTOP=1) SKIP THE
C        CASE
C
    3 CALL CHKTBL(ISTOP)
      IF(ISTOP.EQ.-1)GO TO 3
      IF(ISTOP.EQ.1)GO TO 10
C
C        NOW THAT THE INPUT DATA AND DISTRIBUTION HAVE BEEN CHECKED,
C        OUTPUT THE INITIAL CONDITIONS AND INITIALIZE OUTPUT COUNTERS
C        (I.E. IPTIM AND JPRTIM), AND THE FLAG FOR THE O.D.E. PACKAGE
C        (I.E. IODEPK).  TWO VARIABLES ARE USED FOR THE OUTPUT COUNTERS
C        SO AS NOT TO PASS THE DO-LOOP COUNTER IN THE COMMON BLOCK
C        /AERSL5/, TO AVOID THE POSSIBLITY OF THE USER CHANGING
C        THE COUNTER IN HIS ROUTINE
C
      CALL COAGCF(0)
      CALL OUTPUT(0)
      IF(ISSTAT.EQ.1)ISSFLG=1
      IF(ISSFLG.EQ.1)CALL STEADY(DUMTIM)
      IF(ISSFLG.EQ.1)CALL OUTPUT(-2)
      IF(ISSTAT.GE.0.OR.ISSTAT.EQ.-2)GO TO 22
      DO 26 I=1,NDISCR
   26 ASAVE(I)=A(NVAR+I)
      CALL STEADY(DUMTIM)
      CALL OUTPUT(-2)
      DO 27 I=1,NDISCR
   27 A(NVAR+I)=ASAVE(I)
   22 IF(NPRNT.EQ.1)GO TO 10
C
      JPRTIM=2
      IPTIM=JPRTIM
    6 JSTART=JPRTIM
      IODEPK=1
C
C        IN THE FOLLOWING DO LOOP TERMINATING WITH STATEMENT NUMBER 5
C        COMPUTE THE SOLUTION OF THE CASE FOR NPRNT OUTPUT TIMES
C
      DO 5 JPRTIM=JSTART,NPRNT
      IPTIM=JPRTIM
   17 CALL ODE(DIFFUN,NVAR+NDISCR*(1-ISSFLG),A,TIME,TOUT(JPRTIM),RELERR,
     $  ABSERR,IODEPK,WORK,IWORK)
      DUMTIM=TIME
      GO TO (13,13,9,7,8,14,18),IODEPK
    9 WRITE(IPRNT,15)TIME
   15 FORMAT(57H0*** ERROR TOLERANCES TOO SMALL, WILL BE INCREASED, TIME
     $=,E12.4)
      GO TO 17
   14 WRITE(IPRNT,12)TIME
   12 FORMAT(65H0*** SOLUTION VANISHES, WILL USE ABSOLUTE ERROR OF 12**-
     $30, TIME=,E10.4)
      ABSERR=1.D-30
      GO TO 17
   13 IF(ISETUP.EQ.1)CALL SETUP(ISPLIN,0,NVAR)
      IF(ISSFLG.EQ.1.AND.ITIMDP.EQ.1)CALL COAGCF(0)
      IF(ISSFLG.EQ.1)CALL STEADY(DUMTIM)
C
C        IF GRID POINTS HAVE BEEN ADDED (I.E. ISTOP=-1), RESTART
C        CALCULATION AND TRY AGAIN TO REACH TOUT(JPRTIM). IF THE
C        DISTRIBUTION IS NEGATIVE AND NO GRID POINTS HAVE BEEN ADDED
C        (I.E. ISTOP=1), SKIP TO THE NEXT CASE.
C
      CALL CHKTBL(ISTOP)
      IF(ISTOP.EQ.1)GO TO 10
      IF(ISTOP.EQ.0)GO TO 21
      TIME=TOUT(JPRTIM-1)
      DUMTIM=TIME
      CALL COAGCF(ISTOP+ITIMDP)
      IF(ISSFLG.EQ.1)CALL STEADY(DUMTIM)
      CALL OUTPUT(ISTOP)
      IF(JPRTIM.EQ.ISSTAT+1)ISSFLG=0
      GO TO 6
   21 CALL OUTPUT(ISTOP)
C
C        CHECK IF THE SPLINE INTERPOLATION METHOD IS TO BE CHANGED OR
C        IF THE STEADY STATE APPROXIMATION IS TO BE USED FOR THE
C        DISCRETE REGIME
C
      IF(ISSTAT.GE.0.OR.ISSFLG.EQ.1)GO TO 23
      DO 24 I=1,NDISCR
   24 ASAVE(I)=A(NVAR+I)
      IF(ITIMDP.EQ.1)CALL COAGCF(0)
      CALL STEADY(DUMTIM)
      CALL OUTPUT(-2)
      IF(ISSTAT.EQ.-1)GO TO 28
      DO 29 I=NVARP1,NVART
      IF(ABS(A(I)-ASAVE(I-NVAR))/RELERR.GT.A(I)+ABSERR)GO TO 28
   29 CONTINUE
      ISSFLG=1
      IODEPK=1
      GO TO 23
   28 DO 25 I=1,NDISCR
   25 A(NVAR+I)=ASAVE(I)
C
   23 IF(JPRTIM.NE.ISWTCH)GO TO 16
      ISPLIN=ISPSWT
      ISETUP=ISETSW
      CALL OUTPUT(-1)
C
   16 IF(JPRTIM.NE.ISSTAT)GO TO 5
      IODEPK=1
      ISSFLG=1
      IF(ITIMDP.EQ.1)CALL COAGCF(0)
      CALL STEADY(DUMTIM)
      CALL OUTPUT(-2)
    5 CONTINUE
      GO TO 10
C
C        PRINT ERROR MESSAGE AND PROCEED TO NEXT CASE
C
    7 WRITE(IPRNT,4)TIME
    4 FORMAT(66H0*** SOMETHING IS WRONG, MORE THAN 500 STEPS NEEDED TO R
     $EACH TIME=,E10.4,39H, RECHECK INPUT OR CONTACT FRED GELBARD)
      GO TO 10
    8 WRITE(IPRNT,11)
   11 FORMAT(46H0*** EQUATIONS SEEM TO BE STIFF TIME REACHED= ,E12.4)
      GO TO 10
   18 WRITE(IPRNT,19)
   19 FORMAT(33H0*** INVALID INPUT TO ODE PACKAGE)
   10 CONTINUE
      STOP
      END
      SUBROUTINE INPUT
C-----------------------------------------------------------------------
C*    THIS SUBROUTINE READS IN THE INPUT DATA, PRINTS THE INPUT DATA,  *
C*    DETERMINES INITIAL GRID POINT LOCATIONS, AND THE VALUE OF THE    *
C*    INITIAL DISTRIBUTION AT THE GRID POINTS                          *
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION HEADNG(10)
      COMMON/AERSL1/IPARM(10)
      COMMON/AERSL2/A(60),X(60),W(40)
      COMMON/AERSL3/Z(24),FACTOR(24),ZMASS(24)
      COMMON/AERSL5/ISAVE,ICONDN,IGRID,IPRNT,IPTIM,IREAD,ISETSW,ISETUP,
     $  ISPSWT,ISPLIN,ISSTAT,ISWTCH,ISSFLG,ITIMDP,NCREMV,NCSORC,
     $  NDCLS(20),NDISCR,NDREMV,NDSORC,NMULP1,NMXVAR,NPRNT,NPTBET,
     $  NQUADP,NVAR,NVART,NVARP1,NVARP2,NVARM1,MAXEVP,MINW
      COMMON/AERSL6/TOUT(16),TIME,XA,XB,XBOXA,ALGXBA,RELERR,ABSERR
      COMMON/AERSL8/WQUAD(12),WTQUAD(12)
C
C        READ AND ECHO PRINT INPUT DATA
C
      READ(IREAD,1)(HEADNG(I),I=1,10),XA,XB,RELERR,ABSERR,NVAR,
     $  NMXVAR,NDISCR,NMULGV,NPRNT,ISWTCH,ISSTAT,IGRID,NPTBET,NCSORC,
     $  NCREMV,NDSORC,NDREMV,ICONDN,ISPLIN,ISETUP,ISPSWT,ISETSW,ITIMDP,
     $  (IPARM(I),I=1,10)
    1 FORMAT(10A4,4E10.4/7I2,6X,I3,7X,11I1,9X,10I1)
C
C             FORCED DEFAULT VALUES
C
      ISSFLG=0
      IF(NDISCR.GT.0)GO TO 2
      NMULGV=0
      NDSORC=0
      NDREMV=0
      ISSTAT=0
C
    2 IF(RELERR.LE.0.D0)RELERR=1.D-3
      IF(NVAR.LT.10)NVAR=10
      IF(NMXVAR.LT.NVAR)NMXVAR=NVAR
      IF(NPRNT.LE.0)NPRNT=1
C
      WRITE(IPRNT,3)(HEADNG(I),I=1,10),XA,XB,RELERR,ABSERR,NVAR,NMXVAR,
     $  NDISCR,NMULGV,NPRNT,ISWTCH,ISSTAT,IGRID,NPTBET,NCSORC
    3 FORMAT(1H1,43X,10A4/25H0SMALLEST PARTICLE VOLUME,E33.4,11X,
     $  23HLARGEST PARTICLE VOLUME,E28.4/
     $  27H0RELATIVE INTEGRATION ERROR,E29.4,11X,
     $  26HABSOLUTE INTEGRATION ERROR,E23.4/
     $  28H0TOTAL NUMBER OF GRID POINTS,I26,13X,
     $  29HMAXIMUM NUMBER OF GRID POINTS,I18,/
     $  25H0NUMBER OF DISCRETE SIZES,I29,13X,
     $  26HNUMBER OF MULTIPLETS GIVEN,I21,/
     $  23H0NUMBER OF OUTPUT TIMES,I31,13X,
     $  37HSWITCH INTERPOLATION AT OUTPUT NUMBER,I10/
     $  30H0STEADY STATE AT OUTPUT NUMBER,I24,13X,
     $  27HNUMBER OF GRID POINTS GIVEN,I20/
     $  31H0NUMBER OF INTERPOLATING POINTS,I23,13X,
     $  33HNUMBER OF CONTINUOUS SOURCE TERMS,I14)
      WRITE(IPRNT,4)NCREMV,NDSORC,NDREMV,ICONDN,ISPLIN,ISETUP,
     $  ISPSWT,ISETSW,ITIMDP,(IPARM(I),I=1,10)
    4 FORMAT(35H0NUMBER OF CONTINUOUS REMOVAL TERMS,I19,13X,
     $  31HNUMBER OF DISCRETE SOURCE TERMS,I16/
     $  33H0NUMBER OF DISCRETE REMOVAL TERMS,I21,13X,
     $  25HCONDENSATION (0=NO/1=YES),I22/
     $  43H0INITIAL SPLINE INTERPOLATION METHOD NUMBER,I11,13X,
     $  44HCALL SETUP BEFORE INTERPOLATING (0=NO/1=YES),I3/
     $  34H0SPLINE NUMBER FOR SWITCHED METHOD,I20,13X,
     $  43HCALL SETUP FOR SWITCHED METHOD (0=NO/1=YES),I4/
     $  52H0TIME DEPENDENT COAG./EVAP. COEFFICIENT (0=NO/1=YES),I2,13X,
     $  32HUSER SUPPLIED PARAMETER SWITCHES,5X,10I2)
C
      READ(IREAD,5)(TOUT(I),I=1,NPRNT)
    5 FORMAT(8E10.4)
      WRITE(IPRNT,23)(I,TOUT(I),I=1,NPRNT)
   23 FORMAT(/55X,12HOUTPUT TIMES/4H0NO.,7X,4HTIME,6X,3HNO.,7X,4HTIME,
     $  6X,3HNO.,7X,4HTIME,6X,3HNO.,7X,4HTIME,6X,3HNO.,7X,4HTIME,
     $  6X,3HN0.,7X,4HTIME/6(I3,E14.4,3X))
      NVARM1=NVAR-1
      NVARP1=NVAR+1
      NVARP2=NVAR+2
      NVART=NVAR+NDISCR
      NMULP1=NMULGV+1
      NMULP2=NMULGV+2
      IGDPM1=IABS(IGRID)+NMULP1
      IGDPM2=IGDPM1+1
C
C        IF THE DISCRETE CONTINUOUS GDE IS USED READ IN THE MULTIPLET
C        GRID POINTS. FOR THE DISCRETE CONTINUOUS GDE, XA CORRESPONDS
C        TO THE MONOMER SIZE ON INPUT. AFTER COMPUTING THE CLUSTER
C        SIZES, XA IS THE SMALLEST SIZE IN THE CONTINUOUS REGIME
C
      IF(NDISCR.EQ.0)GO TO 30
      NDCLS(1)=NDISCR+1
      READ(IREAD,28)(NDCLS(I),I=2,NMULP1)
   28 FORMAT(16I5)
      NDCLS(NMULP1)=2*NDISCR
      WRITE(IPRNT,40)(NDCLS(I),I=1,NMULP1)
   40 FORMAT(/47X,39HGRID POINTS AT THE FOLLOWING MULTIPLETS ,(/12I8))
      READ(IREAD,5)(A(I),I=NVARP1,NVART)
      DO 25 I=1,NDISCR
   25 X(NVAR+I)=XA*DBLE(I)
      DO 29 I=1,NMULP1
   29 X(I)=XA*DBLE(NDCLS(I))
      XA=X(1)
C
   30 XBOXA=XB/XA
      ALGXBA=DLOG(XBOXA)
C
C                       *********************
C        THE REMAINDER OF THE ROUTINE DETERMINES GRID POINT LOCATIONS,
C        THE VALUE OF THE DISTRIBUTION AT THE GRID POINTS, AND THE
C        QUADRATURE POINTS AND WEIGHT FACTORS OVER THE ENTIRE CONTINUOUS
C        DOMAIN.
C                       *********************
C
      X(1)=XA
      X(NVAR)=XB
      W(1)=0.D0
      W(NVAR)=1.D0
C
C        IF USER SUPPLIES GRID POINTS, READ THEM IN AND COMPUTE THE
C        REMAINING GRID POINTS AS LOGARITHMICALLY SPACED IN X.  IF NO
C        GRID POINTS ARE SUPPLIED BY THE USER, ALL GRID POINTS WILL
C        BE LOGARITHMICALLY SPACED IN X.  GRID POINTS ARE READ IN FROM
C        SMALLEST TO LARGEST UNLESS IGRID IS NEGATIVE, THEN THE
C        ABSOLUTE VALUE OF IGRID POINTS ARE READ IN FROM LARGEST TO
C        SMALLEST.
C
      IF(NMULGV.EQ.0)GO TO 15
      DO 21 I=2,NMULP1
   21 W(I)=DLOG(X(I)/XA)/ALGXBA
   15 IF(IGRID.NE.0)GO TO 16
C
C        HERE IF NO GRID POINTS ARE SUPPLIED BY USER
C
      DO 14 I=NMULP2,NVARM1
   14 W(I)=DBLE(I-NMULP1)/DBLE(NVAR-NMULP1)*(1.D0-W(NMULP1))+W(NMULP        
     V1)
      GO TO 7
C
C        HERE IF USER SUPPLIES GRID POINT LOCATIONS
C
   16 IF(IGRID.GT.0)READ(IREAD,5)(X(I),I=NMULP2,IGDPM1)
      IF(IGRID.LT.0)READ(IREAD,5)(X(NVARM1+NMULP2-I),I=NMULP2,IGDPM1)
      DO 9 II=NMULP2,IGDPM1
      I=II
      IF(IGRID.LT.0)I=NVARM1+NMULP2-II
    9 W(I)=DLOG(X(I)/XA)/ALGXBA
C
C        IF ALL THE GRID POINTS HAVE NOT BEEN SPECIFIED BY THE USER,
C        CALCULATE THE REMAINING GRID POINTS
C
      IF(IGDPM1.GE.NVARM1)GO TO 19
      IF(IGRID.LT.0.D0)GO TO 8
C
C        HERE IF GRID POINTS ARE READ IN, IN ASCENDING ORDER
C
      DO 17 I=IGDPM2,NVARM1
   17 W(I)=DBLE(I-IGDPM1)/DBLE(NVAR-IGDPM1)*(1.D0-W(IGDPM1))+W(IGDPM        
     V1)
      GO TO 7
C
C        HERE IF GRID POINTS ARE READ IN, IN DESCENDING ORDER
C
    8 NVGDM1=NVAR+IGRID-1
      DO 10 I=NMULP2,NVGDM1
   10 W(I)=DBLE(I-NMULP1)/DBLE(NVAR+IGRID-NMULP1)*(W(NVAR+IGRID)-
     $  W(NMULP1))+W(NMULP1)
C
C        NOW THAT ALL THE W VALUES OF THE GRID POINTS HAVE BEEN
C        DETERMINED CALCULATE THE PARTICLE SIZES (I.E. X(I)) AT THE
C        GRID POINTS WHICH WERE NOT SPECIFIED BY THE USER
C
    7 DO 34 II=IGDPM2,NVARM1
      I=II
      IF(IGRID.LT.0)I=NMULP1+II-IGDPM1
   34 X(I)=XA*XBOXA**W(I)
C
   19 WRITE(IPRNT,12)(I,X(I),I=1,NVAR)
   12 FORMAT(//55X,11HGRID POINTS/4H0NO.,7X,4HSIZE,6X,3HNO.,7X,4HSIZE,
     $  6X,3HNO.,7X,4HSIZE,6X,3HNO.,7X,4HSIZE,6X,3HNO.,7X,4HSIZE,
     $  6X,3HN0.,7X,4HSIZE/6(I3,E14.4,3X))
C
C        DETERMINE INITIAL VALUES OF THE DISTRIBUTION TO INITIALIZE A(I)
C        IF THE INITIAL TIME IS GREATER THAN ZERO, THIS MEANS THAT THE
C        USER IS RESTARTING A PROBLEM AND THE INITIAL VALUES OF A(I)
C        ARE TO BE READ IN
C
C     IF(TOUT(1).GT.0.D0)GO TO 13
      CALL XINTL(NVAR,X,A)
      DO 6 I=1,NVAR
    6 A(I)=A(I)*ALGXBA*X(I)
      GO TO 11
C  13 READ(IREAD,5)(A(I),I=1,NVAR)
C     DO 22 I=1,NVAR
C  22 A(I)=A(I)*ALGXBA*X(I)
C
C        COMPUTE THE QUADRATURE POINTS AND WEIGHT FACTORS FOR INTEGRATIO
C        OVER THE ENTIRE CONTINUOUS DOMAIN TO OBTAIN THE FIRST MOMENT
C
   11 NQUAD2=NQUADP/2
      DO 32 I=1,NQUADP
      J=MAX0(NQUAD2-I+1,I-NQUAD2)
      FACTOR(I)=.5D0*WTQUAD(J)
      Z(I)=.5D0*(1.D0+DSIGN(1.0D0,DBLE(I-NQUAD2)-0.5D0)*WQUAD(J))
   32 ZMASS(I)=XA*XBOXA**Z(I)
      RETURN
      END
      SUBROUTINE OUTPUT(ISTOP)
C-----------------------------------------------------------------------
C*    THIS SUBROUTINE PRINTS THE DISTRIBUTION AND SEVERAL MOMENTS OF   *
C*    THE DISTRIBUTION AT EACH OUTPUT TIME                             *
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION TOTALQ(12),ZDIST(24)
      COMMON/AERSL2/A(60),X(60),W(40)
      COMMON/AERSL3/Z(24),FACTOR(24),ZVOLM(24)
      COMMON/AERSL5/ISAVE,ICONDN,IGRID,IPRNT,IPTIM,IREAD,ISETSW,ISETUP,
     $  ISPSWT,ISPLIN,ISSTAT,ISWTCH,ISSFLG,ITIMDP,NCREMV,NCSORC,
     $  NDCLS(20),NDISCR,NDREMV,NDSORC,NMULP1,NMXVAR,NPRNT,NPTBET,
     $  NQUADP,NVAR,NVART,NVARP1,NVARP2,NVARM1,MAXEVP,MINW
      COMMON/AERSL6/TOUT(16),TIME,XA,XB,XBOXA,ALGXBA,RELERR,ABSERR
      COMMON/CNEVINT/CNDINT,EVPINT,N1TILDA
      IF(ISTOP.EQ.-2)GO TO 15
C
C        OUTPUT DISTRIBUTION AT THE GRID POINTS
C
      WRITE(IPRNT,6)TIME
    6 FORMAT(1H1,49X,6HTIME =,E10.4,9H         //22X,8HPARTICLE,10X,
     $  8HPARTICLE,6X,11HDN/ALOG(DP),10X,11HDS/ALOG(DP),3X,
     $  11HDV/ALOG(DP)/23X,
     $  6HVOLUME,11X,8HDIAMETER,8X,12HDISTRIBUTION,6X,12HDISTRIBUTION,
     $  6X,12HDISTRIBUTION/19X,6HV (CC),11X,6HD (CM),13X,
     $  9HN(LOG(D)),10X,
     $  9HS(LOG(D)),8X,9HV(LOG(D))/13X,3HNO.,9X,2H  ,16X,2H  ,14X,
     $  4H    ,13X,8H        ,11X,5H     /)
      DO 1 I=1,NVAR
      D=(1.90986D0*X(I))**.33333333333333D0
      DISTD=6.90776D0*A(I)/ALGXBA
      DISTS=3.14159D0*D*D*DISTD
      DISTV=X(I)*DISTD
    1 WRITE(IPRNT,2)I,X(I),D,DISTD,DISTS,DISTV
    2 FORMAT(10X,I5,5X,E10.4,4E18.4)
C
C        COMPUTE INTERPOLATION BETWEEN GRID POINTS
C
      IF(NPTBET.EQ.0)GO TO 4
      WRITE(IPRNT,7)
    7 FORMAT(/50X,25HINTERPOLATED DISTRIBUTION/)
      DO 3 I=2,NVAR
      DO 3 J=1,NPTBET
      WBET=W(I-1)+(W(I)-W(I-1))*DBLE(J)/DBLE(NPTBET+1)
      XBET=XA*XBOXA**WBET
      D=(1.90986D0*XBET)**.33333333333333D0
      CALL DISTW(ISPLIN,NVARM1,1,WBET,ZDIST)
      DISTD=6.90776D0*ZDIST(1)/ALGXBA
      DISTS=3.14159D0*D*D*DISTD
      DISTV=XBET*DISTD
    3 WRITE(IPRNT,2)J+NPTBET*(I-2),XBET,D,DISTD,DISTS,DISTV
C
C        COMPUTE INTEGRAL MOMENTS OF THE DISTRIBUTION IN THE CONTINUOUS
C        REGIME
C
    4 TOTNUM=0.D0
      DMEAN=0.D0
      VMEAN=0.D0
      TOTSUR=0.D0
      TOTVOL=0.D0
      CALL DISTW(ISPLIN,NVARM1,NQUADP,Z,ZDIST)
      DO 10 I=1,NQUADP
      ZDIST(I)=ZDIST(I)*FACTOR(I)
      TOTNUM=TOTNUM+ZDIST(I)
      D=(1.90986D0*ZVOLM(I))**.33333333333333D0
      DMEAN=DMEAN+D*ZDIST(I)
      TOTSUR=TOTSUR+3.14159D0*D*D*ZDIST(I)
   10 TOTVOL=TOTVOL+ZVOLM(I)*ZDIST(I)
C
      IF(TOTNUM.LT.1.D-35)GO TO 11
      DMEAN=DMEAN/TOTNUM
      VMEAN=TOTVOL/TOTNUM
   11 WRITE(IPRNT,13)VMEAN,DMEAN,TOTNUM,TOTSUR,TOTVOL
   13 FORMAT(/20X,11HMEAN VOLUME,6X,13HMEAN DIAMETER,5X,12HTOTAL NUMBER,
     $  4X,18HTOTAL SURFACE AREA,3X,12HTOTAL VOLUME/24X,2H  ,16X,2H  ,
     $  16X,4H    ,12X,8H        ,11X,5H     /E30.4,4E18.4)
C
C       NOTE THAT TOTAL CAN NOT BE CALLED TWICE FOR THE SAME IPTIM
C
      IF(ISTOP.NE.0.OR.ICONDN.EQ.1)GO TO 8
      NSPNR=NCSORC+NCREMV
      IF(NSPNR+NDSORC+NDREMV.GT.0)CALL TOTAL(TOTALQ)
      IF(NSPNR.NE.0)WRITE(IPRNT,14)(I,TOTALQ(I),I=1,NSPNR)
   14 FORMAT(//56X,12HVOLUME ADDED//51X,9HMECHANISM,5X,7H(CC/CC)/(I56,
     $  E18.4))
    8 IF(NDISCR.EQ.0)GO TO 303
C
C            OUTPUT DISCRETE REGIME
C
   15 IF(ISTOP.EQ.-2.OR.ISSFLG.EQ.1)WRITE(IPRNT,16)
   16 FORMAT(//54X,12HSTEADY STATE)
      WRITE(IPRNT,9)
    9 FORMAT(//53X,15HDISCRETE REGIME//22X,8HPARTICLE,10X,8HPARTICLE,
     $  11X,6HNUMBER,9X,12HSURFACE AREA,8X,6HVOLUME/23X,6HVOLUME,11X,
     $  8HDIAMETER,7X,13HCONCENTRATION,6X,13HCONCENTRATION,4X,
     $  13HCONCENTRATION/25X,1HV,17X,1HD,17X,1HN,18X,1HS,16X,1HV/
     $  13X,3HNO.,9X,2H  ,16X,2H  ,14X,4H    ,13X,8H        ,11X,
     $  5H     /)
      TOTNUM=0.D0
      DMEAN=0.D0
      TOTSUR=0.D0
      TOTVOL=0.D0
      DO 5 I=NVARP1,NVART
      D=(1.90986D0*X(I))**.33333333333333D0
      DISTS=3.14159D0*D*D*A(I)
      DISTV=X(I)*A(I)
      TOTNUM=TOTNUM+A(I)
      DMEAN=DMEAN+D*A(I)
      TOTSUR=TOTSUR+DISTS
      TOTVOL=TOTVOL+DISTV
    5 WRITE(IPRNT,2)I-NVAR,X(I),D,A(I),DISTS,DISTV
C
      IF(TOTNUM.LT.1.D-35)GO TO 12
      VMEAN=TOTVOL/TOTNUM
      DMEAN=DMEAN/TOTNUM
   12 WRITE(IPRNT,13)VMEAN,DMEAN,TOTNUM,TOTSUR,TOTVOL
      NDSPNR=NDSORC+NDREMV
      IF(NDSPNR.NE.0.AND.ISTOP.EQ.0)WRITE(IPRNT,14)(I,TOTALQ(I+NSPNR),
     $  I=1,NDSPNR)
303     continue
      RETURN
      END
      SUBROUTINE CHKTBL(ISTOP)
C-----------------------------------------------------------------------
C*    THIS SUBROUTINE CHECKS THE INTERPOLATION FOR NEGATIVE VALUES     *
C*    OF THE DISTRIBUTION AND WILL REGRESS TO THE PREVIOUS OUTPUT      *
C*    TIME AND ADD GRID POINTS AT THOSE LOCATIONS WHERE THE            *
C*    DISTRIBUTION IS NEGATIVE.  ISTOP WILL BE SET TO -1 TO INDICATE   *
C*    TO THE MAIN PROGRAM TO RESTART AND TRY AGAIN.  IF THE MAXIMUM    *
C*    NUMBER OF GRID POINTS HAS ALREADY BEEN REACHED, ISTOP WILL BE    *
C*    SET TO 1 AND THE CASE WILL BE SKIPPED IN THE MAIN PROGRAM.  IF   *
C*    ALL THE INTERPOLATED POINTS AT WHICH THE DISTRIBUTION IS         *
C*    NEGATIVE CAN NOT BE ADDED, AS MANY GRID POINTS AS THERE IS ROOM  *
C*    FOR WILL BE ADDED AND THE TIME STEP WILL BE RETIRED.  IF THE     *
C*    DISTRIBUTION IS NEGATIVE AT ONE OF THE GRID POINTS, THIS         *
C*    USUALLY INDICATES THAT THE TIME STEP WAS TOO LARGE AND SOME OF   *
C*    THE INTERPOLATED POINTS WERE NEGATIVE DURING THE TIME STEP WHICH *
C*    RESULTED IN A NEGATIVE DISTRIBUTION AT THE GRID POINTS.  IF THIS *
C*    HAPPENS AND NONE OF THE INTERPOLATED DISTRIBUTION POINTS ARE     *
C*    NEGATIVE OR THEY WERE NOT EVALUATED, ISTOP WILL BE SET TO 1 AND  *
C*    THE CASE WILL BE SKIPPED IN THE MAIN PROGRAM.                    *
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION ASAVE(60),XTROUB(60),WTROUB(40),WBET(9),ZDIST(9)
      COMMON/AERSL2/A(60),X(60),W(40)
      COMMON/AERSL5/ISAVE,ICONDN,IGRID,IPRNT,IPTIM,IREAD,ISETSW,ISETUP,
     $  ISPSWT,ISPLIN,ISSTAT,ISWTCH,ISSFLG,ITIMDP,NCREMV,NCSORC,
     $  NDCLS(20),NDISCR,NDREMV,NDSORC,NMULP1,NMXVAR,NPRNT,NPTBET,
     $  NQUADP,NVAR,NVART,NVARP1,NVARP2,NVARM1,MAXEVP,MINW
      COMMON/AERSL6/TOUT(16),TIME,XA,XB,XBOXA,ALGXBA,RELERR,ABSERR
      ISTOP=0
      NTROUB=0
      IF(NPTBET.EQ.0)GO TO 1
C
C        CHECK INTERPOLATED DISTRIBUTION FOR NEGATIVE VALUES
C
      DO 27 I=2,NVAR
      DO 3 J=1,NPTBET
    3 WBET(J)=W(I-1)+(W(I)-W(I-1))*DBLE(J)/DBLE(NPTBET+1)
      CALL DISTW(ISPLIN,NVARM1,NPTBET,WBET,ZDIST)
      DO 27 J=1,NPTBET
      IF(ZDIST(J).GT.0.D0)GO TO 27
      NTROUB=NTROUB+1
      WTROUB(NTROUB)=WBET(J)
      XTROUB(NTROUB)=XA*XBOXA**WBET(J)
   27 CONTINUE
      IF(NTROUB.EQ.0)GO TO 1
      ISTOP=1
      CALL OUTPUT(ISTOP)
C
C        IF NO GRID POINTS CAN BE ADDED, SET ISTOP TO 1 AND RETURN
C
      WRITE(IPRNT,6)(I,XTROUB(I),I=1,NTROUB)
    6 FORMAT(1H1//40X,42H*** CURVE FIT NEGATIVE AT FOLLOWING POINTS//
     $  (55X,I4,E13.4))
      IF(NVAR.LT.NMXVAR)GO TO 5
      WRITE(IPRNT,23)
   23 FORMAT(67H0UNABLE TO ADD GRID POINTS SINCE SPECIFIED MAXIMUM HAS B
     $EEN REACHED)
      RETURN
    5 IF(XTROUB(1).GT.X(NMULP1))GO TO 16
      WRITE(IPRNT,22)
   22 FORMAT(79H0*** NEGATIVE DISTRIBUTION IN USER SUPPLIED MULTIPLET RE
     $GION, USER MUST RESTART)
      RETURN
   16 NREPLC=NTROUB
C
C        ADD AS MANY GRID POINTS AS POSSIBLE.  IN CASE THERE IS TROUBLE
C        WITH THE FIRST DISTRIBUTION, PLACE THE A ARRAY IN THE ASAVE
C        ARRAY FOR THE FIRST DISTRIBUTION.
C
      IF(NVAR+NTROUB.GT.NMXVAR)NREPLC=NMXVAR-NVAR
      IF(IPTIM.GT.1)GO TO 30
      DO 24 I=1,NVART
   24 ASAVE(I)=A(I)
   30 DO 2 I=1,NVART
    2 A(I)=ASAVE(I)
C
C        ADD GRID POINTS ONE AT A TIME BY SHIFTING HIGHER GRID POINTS
C        UP. SINCE THE A ARRAY IS NEEDED FOR INTERPOLATION, PLACE THE
C        THE CORRESPONDING VALUES OF A FOR THE NEW GRID POINTS IN THE
C        ASAVE ARRAY.  SIMILARLY SHIFT THE X ARRAY BUT NOT THE W
C        ARRAY, SINCE THE W ARRAY IS NEEDED FOR INTERPOLATION
C
      IF(ISETUP.EQ.1.AND.IPTIM.GT.1.OR.ISETUP.EQ.1.AND.IPTIM.EQ.1.AND.
     $TOUT(1).GT.0.D0)CALL SETUP(ISPLIN,0,NVAR)
      NVPTRL=NVAR+NREPLC
      I=1
      DO 13 K=1,NREPLC
      ISTART=I+1
      DO 8 I=ISTART,NVPTRL
      IF(XTROUB(K).LT.X(I))GO TO 14
    8 CONTINUE
C
   14 DO 9 JJ=I,NVART
      J=NVART+I-JJ
      ASAVE(J+1)=ASAVE(J)
    9 X(J+1)=X(J)
      X(I)=XTROUB(K)
      IF(IPTIM.GT.1.OR.IPTIM.EQ.1.AND.TOUT(1).GT.0.D0)GO TO 25
      CALL XINTL(1,XTROUB(K),ASAVE(I))
      ASAVE(I)=ASAVE(I)*XTROUB(K)*ALGXBA
      GO TO 26
   25 CALL DISTW(ISPLIN,NVARM1,1,WTROUB(K),ZDIST)
      ASAVE(I)=ZDIST(1)
   26 NVART=NVART+1
   13 CONTINUE
C
C        NOW THAT ALL THE GRID POINTS HAVE BEEN ADDED, COMPUTE THE NEW
C        W ARRAY AND REPLACE THE A ARRAY.  ALSO INDICATE TO THE USER
C        WHAT CHANGES HAVE BEEN MADE AND RESET NVAR
C
      NVAR=NVPTRL
      NVARM1=NVAR-1
      NVARP1=NVAR+1
      NVARP2=NVAR+2
      DO 10 I=1,NVAR
      W(I)=DLOG(X(I)/XA)/ALGXBA
   10 A(I)=ASAVE(I)
      IF(NDISCR.EQ.0)GO TO 20
      DO 21 I=NVARP1,NVART
   21 A(I)=ASAVE(I)
   20 WRITE(IPRNT,11)NREPLC
   11 FORMAT(15X,56HTIME STEP WILL BE RETRIED WITH THE ADDITION OF THE F
     $IRST,I3,37H OF THE ABOVE POINTS IN PARTICLE SIZE)
      ISTOP=-1
      IF(ISETUP.EQ.1)CALL SETUP(ISPLIN,1,NVAR)
      RETURN
C
C        CHECK DISTRIBUTION AT GRID POINTS
C
    1 DO 12 I=1,NVAR
      IF(A(I).GT.0.D0)GO TO 12
      NTROUB=NTROUB+1
      XTROUB(NTROUB)=X(I)
   12 CONTINUE
      IF(NTROUB.EQ.0)GO TO 7
      ISTOP=1
      WRITE(IPRNT,4)TIME,(I,XTROUB(I),I=1,NTROUB)
    4 FORMAT(1H1/55X,6HTIME =,E12.4/40X,50H*** DISTRIBUTION NEGATIVE AT
     $FOLLOWING GRID POINTS//(50X,I4,E13.4))
      CALL OUTPUT(ISTOP)
C
    7 IF(NDISCR.EQ.0)GO TO 17
C
C        CHECK CLUSTER CONCENTRATIONS NDCLS ARRAY IS DESTROYED IF
C        ERRORS ARE FOUND
C
      NTROUB=0
      DO 18 I=NVARP1,NVART
      IF(A(I).GE.0.D0)GO TO 18
      NTROUB=NTROUB+1
      NDCLS(NTROUB)=I-NVAR
      XTROUB(NTROUB)=A(I)
   18 CONTINUE
      IF(NTROUB.EQ.0)GO TO 17
      ISTOP=1
      WRITE(IPRNT,19)TIME,(NDCLS(I),XTROUB(I),I=1,NTROUB)
   19 FORMAT(1H1/55X,6HTIME =,E12.4/40X,53H*** CLUSTER CONCENTRATION NEG
     $ATIVE AT FOLLOWING SIZES//(50X,I4,E13.4))
C
C        NOW THAT ALL THE GRID POINTS AND INTERPOLATED POINTS HAVE BEEN
C        CHECKED, SAVE THE A ARRAY IN THE ASAVE ARRAY IN CASE THE
C        DISTRIBUTION AT THE NEXT OUTPUT TIME HAS ANY TROUBLE.
C
   17 IF(NPTBET.EQ.0.OR.ISTOP.EQ.1)RETURN
      DO 15 I=1,NVART
   15 ASAVE(I)=A(I)
      RETURN
      END
      SUBROUTINE TOTAL(TOTALQ)
C-----------------------------------------------------------------------
C*    THIS SUBROUTINE CALCULATES THE TOTAL MASS OF AEROSOL ADDED AND   *
C*    REMOVED BY EACH MECHANISM FROM TIME=TOUT(IPTIM-1) TO TIME=       *
C*    TOUT(IPTIM).  IF THIS ROUTINE IS CALLED AT THE INITIAL TIME (I.E.*
C*    IPTIM=1), THE TOTAL MASSES ADDED/REMOVED ARE INITIALIZED TO ZERO *
C*    AND THE REMOVAL RATES ARE CALCULATED AND STORED.                 *
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION TOTALQ(12),SUM2(6),AVRGX(3),SOURCE(3,24),REMOVE(3,24),
     $  ZDIST(24),TFACT(4),ZTIME(4),AVRGR(6)
      COMMON/AERSL2/A(60),X(60),W(40)
      COMMON/AERSL3/Z(24),FACTOR(24),ZMASS(24)
      COMMON/AERSL5/ISAVE,ICONDN,IGRID,IPRNT,IPTIM,IREAD,ISETSW,ISETUP,
     $  ISPSWT,ISPLIN,ISSTAT,ISWTCH,ISSFLG,ITIMDP,NCREMV,NCSORC,
     $  NDCLS(20),NDISCR,NDREMV,NDSORC,NMULP1,NMXVAR,NPRNT,NPTBET,
     $  NQUADP,NVAR,NVART,NVARP1,NVARP2,NVARM1,MAXEVP,MINW
      COMMON/AERSL6/TOUT(16),TIME,XA,XB,XBOXA,ALGXBA,RELERR,ABSERR
C
      DATA ZTIME/-.86113631159405D0,-.33998104358486D0,.33998104358486D0        
     V,
     $.86113631159405D0/
      DATA TFACT/.34785484513745D0,.65214515486255D0,.65214515486255D0,
     $.34785484513745D0/
C
      NTOTQ=NCSORC+NCREMV+NDSORC+NDREMV
      IF(NTOTQ.EQ.0)RETURN
C
C        INITIALIZE TOTAL MASS ADDED AND REMOVED
C
      IF(IPTIM.NE.1)GO TO 2
      DO 4 I=1,NTOTQ
    4 TOTALQ(I)=0.D0
C
C
C
C        COMPUTE MASS ADDED TO THE CONTINUOUS REGIME FROM THE LAST
C        OUTPUT TIME TO THE CURRENT OUTPUT TIME BY USING A NQUADP
C        QUADRATURE FORMULA IN X AND A 4 POINT QUADRATURE FORMULA
C        IN TIME
C
    2 NTSORC=NCSORC+NDSORC
      IF(NCSORC+NCREMV.EQ.0)GO TO 10
      CALL DISTW(ISPLIN,NVARM1,NQUADP,Z,ZDIST)
      DO 1 I=1,NQUADP
    1 ZDIST(I)=ZDIST(I)/(ZMASS(I)*ALGXBA)
   10 IF(IPTIM.EQ.1.OR.NTSORC.EQ.0)GO TO 17
      TSTART=TOUT(IPTIM-1)
      TFINSH=TOUT(IPTIM)
      IF(NCSORC.EQ.0)GO TO 11
      DO 31 J=1,NCSORC
   31 SUM2(J)=0.D0
C
      DO 32 K=1,4
      DO 33 J=1,NCSORC
   33 AVRGX(J)=0.D0
      CALL CSOURC(NQUADP,.5D0*(ZTIME(K)*(TFINSH-TSTART)+TFINSH+TSTART),
     $  ZMASS,ZDIST,SOURCE,REMOVE)
      DO 34 I=1,NQUADP
      DO 34 J=1,NCSORC
   34 AVRGX(J)=AVRGX(J)+SOURCE(J,I)*FACTOR(I)*ZMASS(I)**2
      DO 32 J=1,NCSORC
   32 SUM2(J)=SUM2(J)+TFACT(K)*AVRGX(J)
C
      DO 35 J=1,NCSORC
   35 TOTALQ(J)=TOTALQ(J)+.5D0*(TFINSH-TSTART)*SUM2(J)*ALGXBA
   11 IF(NDSORC.EQ.0)GO TO 17
C
C        COMPUTE MASS ADDED IN THE DISCRETE REGIME FROM THE PAST
C        OUTPUT TIME TO THE CURRENT OUTPUT TIME
C
      DO 24 J=1,NDSORC
   24 SUM2(J)=0.D0
C
      DO 37 K=1,4
      DUMTIM=.5D0*(ZTIME(K)*(TFINSH-TSTART)+TFINSH+TSTART)
      DO 38 J=1,NDSORC
   38 AVRGX(J)=0.D0
      CALL DSOURC(NDISCR,DUMTIM,A(NVARP1),SOURCE,REMOVE)
      DO 36 I=1,NDISCR
      DO 36 J=1,NDSORC
   36 AVRGX(J)=AVRGX(J)+SOURCE(J,I)*X(I+NVAR)
      DO 37 J=1,NDSORC
   37 SUM2(J)=SUM2(J)+TFACT(K)*AVRGX(J)
C
      DO 26 J=1,NDSORC
   26 TOTALQ(J+NCSORC+NCREMV)=TOTALQ(J+NCSORC+NCREMV)+
     $  SUM2(J)*.5D0*(TFINSH-TSTART)
C
C        COMPUTE THE AVERAGE MASS REMOVAL RATE OF EACH MECHANISM FOR
C        TIME STEP BY SUMMING THE REMOVAL RATES OF EACH MECHANISM AT
C        THE PREVIOUS OUTPUT TIME AND THE CURRENT OUTPUT TIME, AND
C        DIVIDING BY 2.  THIS AVERAGE REMOVAL RATE IS STORED IN
C        AVRGR(I) FOR THE I-TH MECHANISM.  TO DETERMINE THE MASS
C        REMOVED FOR THE TIME STEP, COMPUTE THE TOTAL MASS REMOVED FOR
C        TIME STEP AND STORE THAT VALUE IN BALANC.  THEN THE MASS
C        REMOVED BY THE I-TH MECHANISM IS TOTALQ(I+NCSORC)=AVRGR(I)*
C        BALANC DIVIDED BY THE SUM OF ALL AVRGR(J),J=1,NCREMV.  FOR THE
C        INITIAL CALL (I.E. IPTIM=1), ONLY STORE THE REMOVAL RATE FOR
C        EACH MECHANISM IN THE ARRAY AVRGR.  FOR SUBSEQUENT TIMES,
C        SUM2(I) IS THE REMOVAL RATE OF THE I-TH MECHANISM AT THE
C        CURRENT TIME.  AVRGR(I) IS USED TO TEMPORARILY STORE THE
C        AVERAGE REMOVAL RATE OVER THE TIME STEP, BUT BEFORE
C        RETURNING, AVRGR(I) STORES THE REMOVAL RATE AT THE CURRENT
C        OUTPUT TIME.  THE SAME METHOD IS USED IN THE DISCRETE REGIME.
C
   17 NTREMV=NCREMV+NDREMV
      IF(NTREMV.EQ.0)RETURN
      TOTMAS=0.D0
      DO 18 I=1,NQUADP
   18 TOTMAS=TOTMAS+FACTOR(I)*ZDIST(I)*ZMASS(I)**2
      TOTMAS=TOTMAS*ALGXBA
C
      IF(NDISCR.EQ.0)GO TO 19
      DO 20 I=NVARP1,NVART
   20 TOTMAS=TOTMAS+X(I)*A(I)
C
   19 IF(IPTIM.EQ.1)STARTM=TOTMAS
      DO 21 J=1,NTREMV
   21 SUM2(J)=0.D0
      IF(NCREMV.EQ.0)GO TO 39
C
      CALL CSOURC(NQUADP,TIME,ZMASS,ZDIST,SOURCE,REMOVE)
      DO 22 J=1,NQUADP
      ZDIST(J)=FACTOR(J)*ZMASS(J)**2
      DO 22 I=1,NCREMV
   22 SUM2(I)=SUM2(I)+REMOVE(I,J)*ZDIST(J)
C
      IF(IPTIM.GT.1)GO TO 5
      DO 6 I=1,NCREMV
    6 AVRGR(I)=SUM2(I)
      GO TO 16
    5 DO 9 I=1,NCREMV
    9 AVRGR(I)=.5D0*(SUM2(I)+AVRGR(I))
C
C        COMPUTE MASS REMOVED IN DISCRETE REGIME
C
   16 IF(NDISCR.EQ.0)GO TO 12
   39 CALL DSOURC(NDISCR,TIME,A(NVARP1),SOURCE,REMOVE)
      DO 42 I=1,NDISCR
      DO 42 J=1,NDREMV
   42 SUM2(J+NCREMV)=SUM2(J+NCREMV)+X(I+NVAR)*REMOVE(J,I)
C
      IF(IPTIM.GT.1)GO TO 7
      NCREM1=NCREMV+1
      DO 8 I=NCREM1,NTREMV
    8 AVRGR(I)=SUM2(I)
      RETURN
    7 DO 3 I=NCREM1,NTREMV
    3 AVRGR(I)=.5D0*(SUM2(I)+AVRGR(I))
C
C        FROM A MASS BALANCE DETERMINE THE AEROSOL MASS PER UNIT VOLUME
C        WHICH WAS REMOVED SINCE THE LAST STEP AND STORE THAT IN BALANC
C
   12 IF(IPTIM.EQ.1)RETURN
      BALANC=TOTMAS-STARTM
      DO 25 I=1,NTOTQ
   25 BALANC=BALANC-TOTALQ(I)
C
C        IF MASS WAS REMOVED (I.E. BALANC.LT.0.) DETERMINE THE AMOUNT
C        REMOVED BY EACH MECHANISM
C
      IF(BALANC.GT.0.D0)GO TO 13
      SUM=0.D0
      DO 27 I=1,NTREMV
   27 SUM=SUM+AVRGR(I)
      DO 28 I=1,NCREMV
   28 TOTALQ(I+NCSORC)=AVRGR(I)*BALANC/SUM+TOTALQ(I+NCSORC)
      IF(NDREMV.EQ.0)GO TO 13
      DO 23 I=1,NDREMV
   23 TOTALQ(I+NTSORC+NCREMV)=AVRGR(I+NCREMV)*BALANC/SUM+
     $  TOTALQ(I+NTSORC+NCREMV)
C
C        STORE REMOVAL RATE OF THE CURRENT OUTPUT TIME
C
   13 DO 14 I=1,NTREMV
   14 AVRGR(I)=SUM2(I)
      RETURN
      END
      SUBROUTINE COAGCF(ISTOP)
C-----------------------------------------------------------------------
C*    THIS SUBROUTINE COMPUTES THE QUADRATURE POINTS AND COAGULATION   *
C*    COEFFICIENTS AT THE QUADRATURE POINTS FOR EVALUATING THE         *
C*    COAGULATION INTEGRALS.  THE EVAPORATION COEFFICIENTS ARE ALSO    *
C*    EVALUATED AND STORED                                             *
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION XE(2),WE(2)
      COMMON/AERSL2/A(60),X(60),W(40)
      COMMON/AERSL3/Z(24),FACTOR(24),ZMASS(24)
      COMMON/AERSL4/BESR(20,40),BETADC(20,40),BETDSR(210),EVPPLS(40),
     $  EVPSTR(60),FACT1A(24,40),FACT1B(24,40),FACT2(24,60),FACTE1(24),
     $  FACTE3(4),MAXGDC(40),WD(20,40),WMZ1(24,40),WPLS(40),Z1(24,40),
     $  Z2(24,40),ZE(4)
      COMMON/AERSL5/ISAVE,ICONDN,IGRID,IPRNT,IPTIM,IREAD,ISETSW,ISETUP,
     $  ISPSWT,ISPLIN,ISSTAT,ISWTCH,ISSFLG,ITIMDP,NCREMV,NCSORC,
     $  NDCLS(20),NDISCR,NDREMV,NDSORC,NMULP1,NMXVAR,NPRNT,NPTBET,
     $  NQUADP,NVAR,NVART,NVARP1,NVARP2,NVARM1,MAXEVP,MINW
      COMMON/AERSL6/TOUT(16),TIME,XA,XB,XBOXA,ALGXBA,RELERR,ABSERR
      COMMON/AERSL8/WQUAD(12),WTQUAD(12)
C
      DATA XE/.33998104358486D0,.86113631159405D0/
      DATA WE/.65214515486255D0,.34785484513745D0/
C
C
C        DETERMINE THE QUADRATURE POINTS AND FACTORS NEEDED TO COMPUTE
C        THE FIRST COAGUALTION INTEGRAL, I.E. THE INTEGRAL OF
C
C                        Y           Z1                        W(MW)
C         BETA(XA*(XB/XA) ,XA*(XB/XA)  )*M(Y,T)*M(Z1,T)*(XB/XA)
C         ----------------------------------------------------------
C                          W(MW)                      Z1
C                   (XB/XA)         -          (XB/XA)
C
C
C                                   Z1
C              - BETA(X(MW),XA*XBOXA  )*M(Z1,T)*M(W(MW),T)
C
C
C        AS Z1 VARIES FROM ZERO TO  W(MW)-LN(2)/LN(XB/XA)
C        WHERE
C                      (       W(MW)                Z1)
C                 Y= LN((XB/XA)       -      (XB/XA)  )
C                    ----------------------------------
C                                   LN(XB/XA)
C
C        M(W,T)=DISTRIBUTION FUNCTION OF DIMENSIONLESS PARTICLE SIZE W
C          AND TIME T
C        A NQUADP POINT GAUSSIAN LEGENDRE QUADRATURE IS USED, TAKEN FROM
C        THE HANDBOOK OF MATHEMATICAL FUNCTIONS BY MILTON ABRAMOWITZ AND
C        IRENE STEGUN, DOVER PUBLICATIONS INC., N.Y. TABLE 25.4 PAGE
C        917. FOR A COMPLETE DESCRIPTION OF QUADRATURE SEE B.CARNAHAN,
C        H.A.LUTHER AND J.O.WILKES,'APPLIED NUMERICAL METHODS',JOHN
C        WILEY AND SONS, PAGES 100-105 (1969)
C
      NQUAD2=NQUADP/2
      TXA=DLOG(2.D0)/ALGXBA
      DO 14 I=1,NVAR
   14 IF(W(NVAR-I+1).GT.TXA)MINW=NVAR-I+1
C
      DO 5 MW=MINW,NVAR
      UPPER=.5D0*(W(MW)-TXA)
      XBXAW=X(MW)/XA
      DO 3 I=1,NQUADP
      J=MAX0(NQUAD2-I+1,I-NQUAD2)
    3 Z1(I,MW)=UPPER*(1.D0+DSIGN(1.D0,DBLE(I-NQUAD2)-.5D0)*WQUAD(J))
      DO 12 I=1,NQUADP
   12 Z2(I,MW)=XA*XBOXA**Z1(I,MW)
      CALL BETA(NQUADP,TIME,X(MW),Z2(1,MW),FACT1B(1,MW))
      DO 5 I=1,NQUADP
      J=MAX0(NQUAD2-I+1,I-NQUAD2)
      FACT1B(I,MW)=FACT1B(I,MW)*WTQUAD(J)*UPPER
      BWMZ1=XBXAW-XBOXA**Z1(I,MW)
      WMZ1(NQUADP-I+1,MW)=DLOG(BWMZ1)/ALGXBA
      CALL BETA(1,TIME,Z2(I,MW),XA*BWMZ1,FACT1A(I,MW))
    5 FACT1A(I,MW)=FACT1A(I,MW)*WTQUAD(J)*UPPER*XBXAW/BWMZ1
C
C        DETERMINE THE QUADRATURE POINTS AND FACTORS NEEDED TO COMPUTE
C        SECOND COAGUATION INTEGRAL, I.E. THE INTEGRAL OF
C
C         BETA(X(MW),XA*XBOXA**Z2,TIME)*M(Z2,TIME)*M(W(MW),TIME)
C
C        AS Z2 VARIES FROM W(MW)-LN(2)/LN(XB/XA) TO ONE.  IF THIS LOWER
C        LIMIT IS NEGATIVE, THEN SUBSTITUTE ZERO FOR THE LOWER LIMIT.
C
      DO 8 MW=1,NVAR
      BOTTOM=DMAX1(0.D0,W(MW)-TXA)
      DO 15 I=1,NQUADP
      J=MAX0(NQUAD2-I+1,I-NQUAD2)
      Z2(I,MW)=(WQUAD(J)*DSIGN(1.D0,DBLE(I-NQUAD2)-.5D0)*(1.D0-BOTTOM)        
     V+1.+
     $  BOTTOM)*.5D0
   15 FACTE1(I)=XA*XBOXA**Z2(I,MW)
      CALL BETA(NQUADP,TIME,X(MW),FACTE1,FACT2(1,MW))
      DO 8 I=1,NQUADP
      J=MAX0(NQUAD2-I+1,I-NQUAD2)
    8 FACT2(I,MW)=FACT2(I,MW)*WTQUAD(J)*(1.D0-BOTTOM)*.5D0
C
C                  ****************************************
C        THE REST OF THE ROUTINE IS USED ONLY IF THE DISCRETE -
C        CONTINUOUS G-D-E IS REQUESTED
C                  ****************************************
C
      IF(NDISCR.EQ.0)RETURN
C
C        IN CASE GRID POINTS HAVE BEEN ADDED (I.E. ISTOP=-1), DO NOT
C        WASTE COMPUTER TIME RECOMPUTING CLUSTER-CLUSTER COAGULATION
C        AND EVAPORATION COEFFICIENTS
C
      IF(ISTOP.EQ.-1)GO TO 2
C
C        COMPUTE THE CLUSTER - CLUSTER COAGULATION COEFFICIENTS, NOTE
C        THAT THE COEFFICIENT IS A SYMMETRIC FUNCTION OF ITS ARGUMENTS
C        AND THUS A SIGNIFICANT AMOUNT OF STORAGE CAN BE SAVED
C
      DO 6 I=1,NDISCR
      NBEFR=(I-1)*NDISCR-((I-1)*(I-2))/2
    6 CALL BETA(NDISCR-I+1,TIME,X(I+NVAR),X(I+NVAR),BETDSR(NBEFR+1))
C
C        COMPUTE THE FOUR QUADRATURE POINTS AND FACTORS NEEDED FOR
C        DETERMINING THE FORMATION RATE OF THE LARGEST CLUSTER DUE TO
C        EVAPORATION IN THE DISCRETE REGIME
C
      UPPER=DLOG((XA+X(NVARP1))/XA)/ALGXBA
      DO 11 I=1,4
      J=MAX0(3-I,I-2)
      ZE(I)=.5D0*UPPER*(1.D0+DSIGN(1.D0,DBLE(I)-2.5D0)*XE(J))
      CALL EVAP(1,TIME,XA*XBOXA**ZE(I),FACTE3(I))
   11 FACTE3(I)=FACTE3(I)*UPPER*.5D0*WE(J)
C
C        COMPUTE THE QUADRATURE FACTORS FOR THE NET RATE OF MONOMER
C        EVAPORATION FROM THE CONTINUOUS REGIME
C
      CALL EVAP(NQUADP,TIME,ZMASS,FACTE1)
      DO 7 I=1,NQUADP
    7 FACTE1(I)=FACTE1(I)*FACTOR(I)
C
C       COMPUTE THE QUADRATURE FACTORS NEEDED FOR THE SCAVENGING OF
C       CLUSTERS BY PARTICLES IN THE CONTINUOUS REGIME
C
    2 DO 4 MW=NVARP1,NVART
      CALL BETA(NQUADP,TIME,X(MW),ZMASS,FACT2(1,MW))
      DO 4 I=1,NQUADP
    4 FACT2(I,MW)=FACT2(I,MW)*FACTOR(I)
C
C        COMPUTE THE SIZE AND EVAPORATION COEFFICIENTS OF PARTICLES ONE
C        MONOMER LARGER THAN THE PARTICLES AT THE GRID POINTS
C
      MAXEVP=0
      DO 29 MW=1,NVARM1
      EVPSTR(MW)=X(MW)+X(NVARP1)
      IF(EVPSTR(MW).GT.XB)GO TO 9
      WPLS(MW)=DLOG(EVPSTR(MW)/XA)/ALGXBA
      MAXEVP=MW
   29 CONTINUE
    9 CALL EVAP(MAXEVP,TIME,EVPSTR,EVPPLS)
      DO 16 I=1,MAXEVP
   16 EVPPLS(I)=X(I)*EVPPLS(I)/EVPSTR(I)
C
C        STORE THE EVAPORATION COEFFICIENTS AT THE GRID POINTS AND FOR
C        FOR CLUSTERS. (NOTE THAT EVPSTR(NVAR+1) SHOULD NEVER BE USED,
C        HOWEVER FOR PROGRAM CLARITY EVPSTR(NVAR+I) IS THE EVAPORATION
C        COEFFICIENT OF THE I-TH CLUSTER).
C
      CALL EVAP(NVAR,TIME,X,EVPSTR)
      CALL EVAP(NDISCR-1,TIME,X(NVARP2),EVPSTR(NVARP2))
C
C        COMPUTE THE W SIZES (I.E. WD) AND COAGULATION COEFFICIENTS (I.E
C        BESR) FOR THE NET RATE OF GROWTH DUE TO A DISCRETE CLUSTER
C        COAGULATING WITH A PARTICLE IN THE CONTINUOUS REGIME
C
      MAXGDC(1)=0
      DO 27 MW=2,NVAR
      MAXG=NDISCR
      IF(MW.LE.NMULP1)MAXG=NDCLS(MW)-NDISCR-1
      MAXGDC(MW)=MAXG
      DO 27 J=1,MAXG
      JPNVAR=J+NVAR
      DUM=X(MW)-X(JPNVAR)
      CALL BETA(1,TIME,DUM,X(JPNVAR),BESR(J,MW))
      BESR(J,MW)=BESR(J,MW)*X(MW)/DUM
   27 WD(J,MW)=DLOG((DUM)/XA)/ALGXBA
C
C       COMPUTE THE COAGULATION COEFFICIENTS BETWEEN CLUSTERS AND
C       PARTICLES IN THE CONTINUOUS REGIME
C
      DO 30 J=1,NVAR
   30 CALL BETA(NDISCR,TIME,X(J),X(NVARP1),BETADC(1,J))
      RETURN
      END
      BLOCK DATA
C-----------------------------------------------------------------------
C*    THIS DATA BLOCK CONTAIN THE QUADRATURE POINTS AND WEIGHT         *
C*    FACTORS FOR THE GUASSIAN-LEGENDRE QUADRATURES.  NQUADP IS        *
C*    THE NUMBER OF QUADRATURE POINTS AND IT MUST BE AN EVEN NUMBER    *
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON/AERSL5/ISAVE,ICONDN,IGRID,IPRNT,IPTIM,IREAD,ISETSW,ISETUP,
     $  ISPSWT,ISPLIN,ISSTAT,ISWTCH,ISSFLG,ITIMDP,NCREMV,NCSORC,
     $  NDCLS(20),NDISCR,NDREMV,NDSORC,NMULP1,NMXVAR,NPRNT,NPTBET,
     $  NQUADP,NVAR,NVART,NVARP1,NVARP2,NVARM1,MAXEVP,MINW
      COMMON/AERSL8/WQUAD(12),WTQUAD(12)
C
C     DATA NQUADP/12/
C     DATA WQUAD/.125233408511469  ,.367831498998180  ,
C    $.587317954286617  ,.769902674194305  ,
C    $.904117256370475  ,.981560634246719  /
C     DATA WTQUAD/.249147045813403  ,.233492536538355  ,
C    $.203167426723066  ,.160078328543346  ,
C    $.106939325995318  ,.047175336386512  /
C
C     DATA NQUADP/40/
C     DATA WQUAD/.038772417506050821933  ,.116084070675255208483  ,
C    $.192697580701371099716  ,.268152185007253681141  ,
C    $.341994090825758473007  ,.413779204371605001525  ,
C    $.483075801686178712909  ,.549467125095128202076  ,
C    $.612553889667980237953  ,.671956684614179548379  ,
C    $.727318255189927103281  ,.778305651426519387695  ,
C    $.824612230833311663196  ,.865959503212259503821  ,
C    $.902098806968874296728  ,.932812808278676533361  ,
C    $.957916819213791655805  ,.977259949983774262663  ,
C    $.990726238699457006453  ,.998237709710559200350  /
C     DATA WTQUAD/.077505947978424811264  ,.077039818164247965588  ,
C    $.076110361900626242372  ,.074723169057968264200  ,
C    $.072886582395804059061  ,.070611647391286779695  ,
C    $.067912045815233903826  ,.064804013456601038075  ,
C    $.061306242492928939167  ,.057439769099391551367  ,
C    $.053227846983936824355  ,.048695807635072232061  ,
C    $.043870908185673271992  ,.038782167974472017640  ,
C    $.033460195282547847393  ,.027937006980023401098  ,
C    $.022245849194166957262  ,.016421058381907888713  ,
C    $.010498284531152813615  ,.004521277098533191258  /
C
      DATA NQUADP/24/
      DATA WQUAD/.064056892862605626085D0,.191118867473616309159D0,
     $.315042679696163374387D0,.433793507626045138487D0,
     $.545421471388839535658D0,.648093651936975569252D0,
     $.740124191578554364244D0,.820001985973902921954D0,
     $.886415527004401034213D0,.938274552002732758524D0,
     $.974728555971309498198D0,.995187219997021360180D0/
      DATA WTQUAD/.127938195346752156974D0,.125837456346828296121D0,
     $.121670472927803391204D0,.115505668053725601353D0,
     $.107444270115965634783D0,.097618652104113888270D0,
     $.086190161531953275917D0,.073346481411080305734D0,
     $.059298584915436780746D0,.044277438817419806169D0,
     $.028531388628933663181D0,.012341229799987199547D0/
      DATA IREAD,IPRNT/1,2/
      END
      SUBROUTINE DIFFUN(TIME,ADIF,DADT)
C-----------------------------------------------------------------------
C*    THIS SUBROUTINE COMPUTES THE DERIVATIVE OF ADIF(I) WITH RESPECT  *
C*    TO TIME AND STORES THE RESULT IN DADT(I).  FOR THE DISCRETE -    *
C*    CONTINUOUS G-D-E, DADT(I) IS THE DERIVATIVE OF THE CLUSTER       *
C*    CONCENTRATIONS WITH RESPECT TO TIME FOR I=NVARP1 TO NVART, WHERE *
C*    DADT(NVARP1) IS FOR THE MONOMER AND DADT(NVARP1+1) IS FOR THE    *
C*    DIMER, ETC.)                                                     *
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION ADIF(60),DADT(60),ZDIST(40),SOURCE(3,40),REMOVE(3,40),
     $  ZDIST2(40)
      COMMON/AERSL2/A(60),X(60),W(40)
      COMMON/AERSL3/Z(24),FACTOR(24),ZMASS(24)
      COMMON/AERSL4/BESR(20,40),BETADC(20,40),BETDSR(210),EVPPLS(40),
     $  EVPSTR(60),FACT1A(24,40),FACT1B(24,40),FACT2(24,60),FACTE1(24),
     $  FACTE3(4),MAXGDC(40),WD(20,40),WMZ1(24,40),WPLS(40),Z1(24,40),
     $  Z2(24,40),ZE(4)
      COMMON/AERSL5/ISAVE,ICONDN,IGRID,IPRNT,IPTIM,IREAD,ISETSW,ISETUP,
     $  ISPSWT,ISPLIN,ISSTAT,ISWTCH,ISSFLG,ITIMDP,NCREMV,NCSORC,
     $  NDCLS(20),NDISCR,NDREMV,NDSORC,NMULP1,NMXVAR,NPRNT,NPTBET,
     $  NQUADP,NVAR,NVART,NVARP1,NVARP2,NVARM1,MAXEVP,MINW
      COMMON/AERSL6/TOUT(16),DUMTIM,XA,XB,XBOXA,ALGXBA,RELERR,ABSERR
C
      BETAFC(I,J)=BETDSR(J+(I-1)*NDISCR-(I*(I-1))/2)
C
      DO 3 I=1,NVART
    3 A(I)=ADIF(I)
      DUMTIM=TIME
      IF(ISETUP.EQ.1)CALL SETUP(ISPLIN,0,NVAR)
      IF(ITIMDP.EQ.1)CALL COAGCF(0)
      IF(ISSFLG.EQ.1)CALL STEADY(DUMTIM)
C
      DO 13 MW=1,NVAR
   13 DADT(MW)=0.D0
C
C        COMPUTE THE FIRST COAGULATION INTEGRAL BY QUADRATURE
C
      DO 5 MW=MINW,NVAR
      CALL DISTW(ISPLIN,NVARM1,NQUADP,Z1(1,MW),ZDIST)
      CALL DISTW(ISPLIN,NVARM1,NQUADP,WMZ1(1,MW),ZDIST2)
      SUM=0.D0
      DO 4 I=1,NQUADP
    4 SUM=SUM+ZDIST(I)*(FACT1A(I,MW)*ZDIST2(NQUADP-I+1)-FACT1B(I,MW)*
     $  A(MW))
    5 DADT(MW)=SUM
C
C        COMPUTE THE SECOND COAGULATION INTEGRAL BY QUADRATURE
C
      DO 35 MW=1,NVAR
      CALL DISTW(ISPLIN,NVARM1,NQUADP,Z2(1,MW),ZDIST)
      SUM=0.D0
      DO 10 I=1,NQUADP
   10 SUM=SUM+FACT2(I,MW)*ZDIST(I)
   35 DADT(MW)=DADT(MW)-SUM*A(MW)
C
C        IF CONDENSATION IS INCLUDED COMPUTE THE DERIVATIVE WITH RESPECT
C        TO W OF THE RATE OF CHANGE OF W WITH RESPECT TO TIME, TIMES THE
C        'M' DISTRIBUTION FUNCTION.  IN TERMS OF THE PARTICLE SIZE
C        X, PARTICLE SIZE GROWTH RATE 'RATE',THE DERIVATIVE OF 'RATE'
C        WITH RESPECT TO PARTICLE SIZE 'PARTAL', THE DISTRIBUTION
C        FUNCTION M(W,TIME), AND THE DERIVATIVE OF M(W,TIME) WITH
C        RESPECT TO W, DM/DW, THE EQUIVALENT EXPRESSION IS:
C
C                RATE       DM               (         RATE)
C            ------------ * --  +  M(W,TIME)*(PARTAL - ----)
C            X  *  ALGXBA   DW               (          X  )
C
      IF(ICONDN.EQ.0)GO TO 30
      CALL GROWTH(NVAR,DUMTIM,X,ZDIST,ZDIST2)
      DO 33 MW=1,NVAR
   33 DADT(MW)=DADT(MW)-A(MW)*(ZDIST2(MW)-ZDIST(MW)/X(MW))
      CALL DERIVT(ISPLIN,NVAR,ZDIST2)
      DO 34 MW=1,NVAR
   34 DADT(MW)=DADT(MW)-ZDIST(MW)*ZDIST2(MW)/(X(MW)*ALGXBA)
      DADT(1)=DADT(1)+BOUNDR(DUMTIM)*ALGXBA*X(1)
C
C       COMPUTE THE EFFECT OF ANY SOURCE OR REMOVAL MECHANISMS
C
   30 IF(NCSORC+NCREMV.EQ.0)GO TO 16
      DO 31 I=1,NVAR
   31 ZDIST(I)=A(I)/(ALGXBA*X(I))
      CALL CSOURC(NVAR,DUMTIM,X,ZDIST,SOURCE,REMOVE)
      DO 19 MW=1,NVAR
      SUM=0.D0
      IF(NCREMV.EQ.0)GO TO 17
      DO 18 I=1,NCREMV
   18 SUM=SUM+REMOVE(I,MW)
   17 IF(NCSORC.EQ.0)GO TO 19
      DO 20 I=1,NCSORC
   20 SUM=SUM+SOURCE(I,MW)
   19 DADT(MW)=DADT(MW)+ALGXBA*X(MW)*SUM
   16 IF(NDISCR.EQ.0)RETURN
C
C        COMPUTE THE NET RATE OF GROWTH IN THE CONTINUOUS REGIME DUE TO
C        DISCRETE CLUSTERS COAGULATING WITH CONTINUOUS PARTICLES.  TO
C        REDUCE ROUND OFF ERROR START WITH THE LARGEST DISCRETE PARTICLE
C        SINCE IT PROBABLY HAS THE SMALLEST EFFECT
C
      DO 8 MW=1,NVAR
      IF(MW.GT.1)CALL DISTW(ISPLIN,NVARM1,MAXGDC(MW),WD(1,MW),ZDIST)
      DO 8 II=1,NDISCR
      I=NDISCR-II+1
      TERM=-A(MW)*BETADC(I,MW)
      IF(I.LE.MAXGDC(MW))TERM=TERM+BESR(I,MW)*ZDIST(I)
    8 DADT(MW)=DADT(MW)+A(I+NVAR)*TERM
C
C       COMPUTE PARTICLE FORMATION RATE DUE TO TWO DISCRETE CLUSTERS
C       COAGULATING TO FORM A PARTICLE IN THE DISCRETE REGIME
C
      DO 15 MW=1,NMULP1
      SUM=0.D0
      MSMLS=NDCLS(MW)-NDISCR
      MSIZE=NDCLS(MW)/2
      DO 14 I=MSMLS,MSIZE
      J=NDCLS(MW)-I
      TERM=BETAFC(I,J)*A(I+NVAR)*A(J+NVAR)*(1.D0-.5D0*DBLE(I/J))
   14 SUM=SUM+TERM
   15 DADT(MW)=DADT(MW)+SUM*X(I)*ALGXBA/X(NVARP1)
C
C        COMPUTE THE NET RATE OF LOSS DUE TO EVAPORATION OF MONOMER
C
      CALL DISTW(ISPLIN,NVARM1,MAXEVP,WPLS,ZDIST)
      DO 32 MW=1,MAXEVP
   32 DADT(MW)=DADT(MW)+(EVPPLS(MW)*ZDIST(MW)-EVPSTR(MW)*A(MW))
C
C                      *******************
C       THE REMAINDER OF THE SUBROUTINE DETERMINES THE RATE OF CHANGE OF
C       THE DISCRETE CLUSTER CONCENTRATIONS WITH RESPECT TO TIME
C                      *******************
C
      IF(ISSFLG.EQ.1)RETURN
C
C        COMPUTE THE NET RATE OF MONOMER FORMATION DUE TO EVAPORATION
C        FROM CLUSTERS IN THE DISCRETE REGIME
C
      SUM=0.D0
      NVARP3=NVAR+3
      IF(NVARP3.GT.NVART)GO TO 28
      DO 2 I=NVARP3,NVART
    2 SUM=SUM+(EVPSTR(I)-BETDSR(I-NVAR)*A(NVARP1))*A(I)
C
C        COMPUTE THE NET RATE OF MONOMER FORMATION DUE TO EVAPORATION
C        FROM PARTICLES IN THE CONTINUOUS REGIME
C
   28 CALL DISTW(ISPLIN,NVARM1,NQUADP,Z,ZDIST)
      DO 6 I=1,NQUADP
    6 SUM=SUM+(FACTE1(I)-FACT2(I,NVARP1)*A(NVARP1))*ZDIST(I)
C
C        COMPUTE THE EFFECT OF ANY SOURCES AND OR REMOVAL MECHANISMS
C
      IF(NDSORC+NDREMV.EQ.0)GO TO 21
      CALL DSOURC(NDISCR,DUMTIM,A(NVARP1),SOURCE,REMOVE)
      IF(NDREMV.EQ.0)GO TO 22
      DO 23 I=1,NDREMV
   23 SUM=SUM+REMOVE(I,1)
   22 IF(NDSORC.EQ.0)GO TO 21
      DO 24 I=1,NDSORC
   24 SUM=SUM+SOURCE(I,1)
   21 DADT(NVARP1)=SUM+(EVPSTR(NVARP2)+EVPSTR(NVARP2)-BETDSR(2)*
     $  A(NVARP1))*A(NVARP2)-BETDSR(1)*A(NVARP1)**2
C
C        COMPUTE THE NET RATE OF CHANGE OF THE DISCRETE CLUSTERS DUE TO
C        COAGUALTION WITHIN THE DISCRETE REGIME.  TO REDUCE ROUND OFF
C        ERROR, START WITH THE LARGEST CLUSTER
C
      DO 1 MW=NVARP2,NVART
      MWMNVR=MW-NVAR
      SUM=0.D0
      MAXSZ=MWMNVR/2
      DO 9 II=1,NDISCR
      I=NDISCR-II+1
      TERM=0.D0
      IF(I.LE.MAXSZ)TERM=BETAFC(I,MWMNVR-I)*A(MW-I)*
     $  (1.D0-.5D0*DBLE(I/(MWMNVR-I)))
    9 SUM=SUM+A(I+NVAR)*(TERM-BETAFC(MIN0(I,MWMNVR),MAX0(I,MWMNVR))*
     $  A(MW))
C
C        COMPUTE THE LOSS OF CLUSTERS DUE TO COAGULATION WITH PARTICLES
C        IN THE CONTINUOUS REGIME
C
      SUM2=0.D0
      DO 11 I=1,NQUADP
   11 SUM2=SUM2+FACT2(I,MW)*ZDIST(I)
C
C        COMPUTE THE LOSS OF CLUSTERS DUE TO EVAPORATION.  FOR THE
C        LARGEST CLUSTER INTEGRATE THE CONTINUOUS DISTRIBUTION FROM THE
C        SMALLEST CONTINUOUS PARTICLE TO THE SMALLEST CONTINUOUS
C        PARTICLE PLUS A MONOMER.  SINCE A VERY SMALL REGION IS BEING
C        INTEGRATED ONLY A FOUR POINT QUADRATURE IS REQUIRED
C
      SUM=SUM-A(MW)*(EVPSTR(MW)+SUM2)
      IF(MW.LT.NVART)GO TO 7
      CALL DISTW(ISPLIN,NVARM1,4,ZE,ZDIST)
      DO 12 I=1,4
   12 SUM=SUM+FACTE3(I)*ZDIST(I)
      GO TO 29
    7 SUM=SUM+A(MW+1)*EVPSTR(MW+1)
   29 IF(NDSORC+NDREMV.EQ.0)GO TO 1
C
C        COMPUTE THE EFFECT OF ANY SOURCE AND/OR REMOVAL MECHANISMS
C
      IF(NDREMV.EQ.0)GO TO 25
      DO 26 I=1,NDREMV
   26 SUM=SUM+REMOVE(I,MWMNVR)
   25 IF(NDSORC.EQ.0)GO TO 1
      DO 27 I=1,NDSORC
   27 SUM=SUM+SOURCE(I,MWMNVR)
    1 DADT(MW)=SUM
      RETURN
      END
      SUBROUTINE STEADY(TIME)
C-----------------------------------------------------------------------
C*    THIS SUBROUTINE COMPUTES THE STEADY STATE CONCENTRATIONS IN THE  *
C*    DISCRETE REGIME USING SUCESSIVE SUBSTITUTION AS THE ITERATION    *
C*    TECHNIQUE                                                        *
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION SCAVNG(40),ATRY(40),STRSRC(40),SOURCE(3,20),
     $  REMOVE(3,20),ZDIST(24)
      COMMON/AERSL2/A(60),X(60),W(40)
      COMMON/AERSL3/Z(24),FACTOR(24),ZMASS(24)
      COMMON/AERSL4/BESR(20,40),BETADC(20,40),BETDSR(210),EVPPLS(40),
     $  EVPSTR(60),FACT1A(24,40),FACT1B(24,40),FACT2(24,60),FACTE1(24),
     $  FACTE3(4),MAXGDC(40),WD(20,40),WMZ1(24,40),WPLS(40),Z1(24,40),
     $  Z2(24,40),ZE(4)
      COMMON/AERSL5/ISAVE,ICONDN,IGRID,IPRNT,IPTIM,IREAD,ISETSW,ISETUP,
     $  ISPSWT,ISPLIN,ISSTAT,ISWTCH,ISSFLG,ITIMDP,NCREMV,NCSORC,
     $  NDCLS(20),NDISCR,NDREMV,NDSORC,NMULP1,NMXVAR,NPRNT,NPTBET,
     $  NQUADP,NVAR,NVART,NVARP1,NVARP2,NVARM1,MAXEVP,MINW
      COMMON/AERSL6/TOUT(16),DUMTIM,XA,XB,XBOXA,RELERR,ABSERR
C
      BETAFC(I,J)=BETDSR(J+(I-1)*NDISCR-(I*(I-1))/2)
C
C        COMPUTE THE VALUE OF THE M DISTRIBUTION AT THE I-TH QUADRATURE
C        POINT AND STORE THE RESULT IN ZDIST(I).
C
      CALL DISTW(ISPLIN,NVARM1,NQUADP,Z,ZDIST)
C
C        COMPUTE THE SCAVENGING RATE OF THE I-TH CLUSTER
C        *** IF THERE ARE REMOVAL MECHANISMS IN THE DISCRETE REGIME
C            THEY MUST BE FIRST ORDER ***
C
      IF(NDSORC+NDREMV.GT.0)CALL DSOURC(NDISCR,TIME,A(NVARP1),SOURCE,
     $  REMOVE)
      DO 21 I=1,NDISCR
      SCAVNG(I)=0.D0
      STRSRC(I)=0.D0
      IF(NDSORC.EQ.0)GO TO 9
      SUM=0.D0
      DO 10 J=1,NDSORC
   10 SUM=SUM+SOURCE(J,I)
      STRSRC(I)=SUM
      SUM=0.D0
    9 IF(NDREMV.EQ.0)GO TO 8
      DO 11 J=1,NDREMV
   11 SUM=SUM+REMOVE(J,I)
      SUM=-SUM/A(I+NVAR)
    8 DO 1 J=1,NQUADP
    1 SUM=SUM+FACT2(J,I+NVAR)*ZDIST(J)
   21 SCAVNG(I)=SUM
C
C        COMPUTE THE MONOMER EVAPORATION RATE FROM THE CONTINUOUS REGIME
C
      EVAPR=0.D0
      DO 22 I=1,NQUADP
   22 EVAPR=EVAPR+FACTE1(I)*ZDIST(I)
      CALL DISTW(ISPLIN,NVARM1,4,ZE,ZDIST)
      EFLUX=0.D0
      DO 23 I=1,4
   23 EFLUX=EFLUX+FACTE3(I)*ZDIST(I)
      DO 25 JCOUNT=1,50
C
C       DETERMINE THE MONOMER CONCENTRATION
C
      B=SCAVNG(1)
      C=EVAPR+EVPSTR(NVARP2)*A(NVARP2)+STRSRC(1)
      DO 6 I=NVARP2,NVART
      B=B+BETDSR(I-NVAR)*A(I)
    6 C=C+EVPSTR(I)*A(I)
      DISCRM=B*B+4.D0*BETDSR(1)*C
      IF(DISCRM.LT.0.D0)GO TO 12
      ATRY(1)=(-B+SQRT(DISCRM))/(2.D0*BETDSR(1))
C
C       DETERMINE THE CLUSTER CONCENTRATIONS FROM THE DIMER TO THE
C       LARGEST CLUSTER IN THE DISCRETE REGIME.
C
      DO 15 I=NVARP2,NVART
      IMNVAR=I-NVAR
      B=SCAVNG(IMNVAR)+EVPSTR(I)
      IM1=I-1
      DO 14 J=NVARP1,IM1
   14 B=B+BETAFC(J-NVAR,IMNVAR)*A(J)
      IF(I.EQ.NVART)GO TO 17
      IP1=I+1
      DO 16 J=IP1,NVART
   16 B=B+BETAFC(IMNVAR,J-NVAR)*A(J)
      C=EVPSTR(IP1)*A(IP1)+STRSRC(IMNVAR)
      GO TO 18
   17 C=EFLUX+STRSRC(IMNVAR)
   18 MAXSZ=IMNVAR/2
      DO 19 JREVS=1,MAXSZ
      J=MAXSZ-JREVS+1
   19 C=C+BETAFC(J,IMNVAR-J)*A(J+NVAR)*A(I-J)*
     $  (1.D0-.5D0*DBLE(J/(IMNVAR-J)))
      DISCRM=B*B+4.D0*BETAFC(IMNVAR,IMNVAR)*C
      IF(DISCRM.LT.0.D0)GO TO 12
   15 ATRY(IMNVAR)=(-B+SQRT(DISCRM))/(2.D0*BETAFC(IMNVAR,IMNVAR))
C
C       CHECK FOR CONVERGENCE OF THE STEADY STATE PROFILE
C
      IERROR=0
      DO 2 I=1,NDISCR
      IF(ABS(A(I+NVAR)-ATRY(I))*RELERR.GT.ATRY(I)+ABSERR)GO TO 3
    2 CONTINUE
      GO TO 4
    3 IERROR=1
    4 DO 5 I=1,NDISCR
    5 A(I+NVAR)=ATRY(I)
      IF(IERROR.EQ.0)RETURN
   25 CONTINUE
   12 WRITE(IPRNT,7)JCOUNT,TIME,(A(I),I=1,NVART),(ATRY(I),I=1,NDISCR)
    7 FORMAT(59H0*** STEADY STATE CONVERGENCE TROUBLE, CONTACT FRED GELB
     $ARD/10X,9HITERATION,I5,3X,4HTIME,E12.4/(8E15.5))
      STOP
      END
      SUBROUTINE CHECK(ISTOP)
C-----------------------------------------------------------------------
C*    THIS SUBROUTINE CHECKS THE USER INPUT FOR OBVIOUS ERRORS AND     *
C*    PRINTS AN ERROR MESSAGE IF ANY ERRORS ARE ENCOUNTERED.  THE      *
C*    ROUTINE WILL RUN THROUGH ALL ERROR CHECKS REGARDLESS OF THE      *
C*    NUMBER OF ERRORS.  IF ANY ERRORS ARE FOUND ISTOP WILL BE SET     *
C*    TO 1 AND THE CASE WILL BE SKIPPED IN THE MAIN PROGRAM            *
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON/AERSL2/A(60),X(60),W(40)
      COMMON/AERSL5/ISAVE,ICONDN,IGRID,IPRNT,IPTIM,IREAD,ISETSW,ISETUP,
     $  ISPSWT,ISPLIN,ISSTAT,ISWTCH,ISSFLG,ITIMDP,NCREMV,NCSORC,
     $  NDCLS(20),NDISCR,NDREMV,NDSORC,NMULP1,NMXVAR,NPRNT,NPTBET,
     $  NQUADP,NVAR,NVART,NVARP1,NVARP2,NVARM1,MAXEVP,MINW
      COMMON/AERSL6/TOUT(16),TIME,XA,XB,XBOXA,ALGXBA,RELERR,ABSERR
      DATA MAXVAR,MAXDIS,MAXTIM,MAXSRC,MAXRMV,MAXDSR,
     $  MAXDRM/40,20,16,3,3,3,3/
      ISTOP=0
C                 **********************
C                    CHECK INPUT DATA
C                 **********************
      IF(XA.LT.XB)GO TO 1
      WRITE(IPRNT,30)
   30 FORMAT(48H0---SMALLEST SIZE MUST BE LESS THAN LARGEST SIZE)
      ISTOP=1
    1 IF(XA.GT.0.D0)GO TO 2
      WRITE(IPRNT,31)
   31 FORMAT(34H0---SMALLEST SIZE MUST BE POSITIVE)
      ISTOP=1
    2 IF(NMXVAR.LE.MAXVAR)GO TO 21
      ISTOP=1
      WRITE(IPRNT,26)MAXVAR
   26 FORMAT(49H0---MAXIMUM NUMBER OF GRID POINTS IS GREATER THAN,I4)
   21 IF(NDISCR.LE.MAXDIS)GO TO 28
      ISTOP=1
      WRITE(IPRNT,33)MAXDIS
   33 FORMAT(44H0---NUMBER OF DISCRETE SIZES IS GREATER THAN,I4)
   28 IF(NPRNT.EQ.1)GO TO 9
      DO 43 I=2,NPRNT
      IF(TOUT(I-1).GT.TOUT(I).OR.TOUT(I-1).LT.0.D0)GO TO 3
   43 CONTINUE
      GO TO 9
    3 ISTOP=1
      WRITE(IPRNT,45)
   45 FORMAT(60H0---OUTPUT TIMES MUST BE NON-NEGATIVE AND IN ASCENDING O
     $RDER)
    9 IF(NPRNT.LE.MAXTIM)GO TO 18
      ISTOP=1
      WRITE(IPRNT,20)MAXTIM
   20 FORMAT(42H0---NUMBER OF OUTPUT TIMES IS GREATER THAN,I4)
   18 IF(NCSORC.LE.MAXSRC)GO TO 34
      ISTOP=1
      WRITE(IPRNT,36)MAXSRC
   36 FORMAT(48H0---NUMBER OF CONTINUOUS SOURCES IS GREATER THAN,I4)
   34 IF(NCREMV.LE.MAXRMV)GO TO 37
      ISTOP=1
      WRITE(IPRNT,40)MAXRMV
   40 FORMAT(49H0---NUMBER OF CONTINUOUS REMOVALS IS GREATER THAN,I4)
   37 IF(NDSORC.LE.MAXDSR)GO TO 41
      ISTOP=1
      WRITE(IPRNT,44)MAXDSR
   44 FORMAT(46H0---NUMBER OF DISCRETE SOURCES IS GREATER THAN,I4)
   41 IF(NDREMV.LE.MAXDRM)GO TO 48
      ISTOP=1
      WRITE(IPRNT,49)MAXDRM
   49 FORMAT(48H0---NUMBER OF DISCRETE REMOVALS IS GREATER THAN ,I4)
   48 IF(NDISCR.EQ.0.AND.NMULP1.EQ.1.OR.NDISCR.GT.0.AND.NMULP1.GT.1)GO
     $TO 19
      WRITE(IPRNT,42)
   42 FORMAT(66H0---IF THERE ARE DISCRETE SIZES AT LEAST 1 MULTIPLET MUS
     $T BE GIVEN)
      ISTOP=1
   19 IF(ICONDN.EQ.1.AND.NDISCR.EQ.0.OR.ICONDN.EQ.0)GO TO 6
      ISTOP=1
      WRITE(IPRNT,11)
   11 FORMAT(62H0---IF CONDENSATION IS INCLUDED THERE CAN BE NO DISCRETE
     $ SIZES)
    6 IF(ICONDN.EQ.0.OR.ICONDN.EQ.1)GO TO 32
      ISTOP=1
      WRITE(IPRNT,35)
   35 FORMAT(48H0---CONDENSATION HAS NOT BEEN PROPERLY SPECIFIED)
   32 IF(ISETUP.EQ.0.OR.ISETUP.EQ.1)GO TO 52
      ISTOP=1
      WRITE(IPRNT,51)
   51 FORMAT(57H0---WHETHER TO CALL SETUP HAS NOT BEEN PROPERLY SPECIFIE
     $D)
   52 IF(ITIMDP.EQ.0.OR.ITIMDP.EQ.1)GO TO 24
      ISTOP=1
      WRITE(IPRNT,62)
   62 FORMAT(80H0---IF COAGULATION COEFFICIENT IS TIME DEPENDENT HAS NOT
     $ BEEN PROPERLY SPECIFIED)
C
C          *************************************
C             CHECK USER SUPPLIED SUBROUTINES
C          *************************************
C
   24 XMEAN=SQRT(XA*XB)
      IF(ICONDN.EQ.0)GO TO 10
      CALL GROWTH(1,TOUT(NPRNT),XMEAN,R3,P1)
      CALL GROWTH(1,TOUT(1),XA*1.00001D0,R2,P1)
      CALL GROWTH(1,TOUT(1),XA,R1,P1)
      IF(R1.GE.0..AND.R2.GE.0..AND.R3.GE.0.D0)GO TO 53
      ISTOP=1
      WRITE(IPRNT,54)
   54 FORMAT(27H0---GROWTH RATE IS NEGATIVE)
   53 R3=(R2-R1)*1.D5/XA
      IF(ABS(R3-P1)*100..LT.ABS(P1))GO TO 10
      ISTOP=1
      WRITE(IPRNT,13)R3,P1
   13 FORMAT(109H0---NUMERICAL DERIVATIVE OF GROWTH RATE FOR SMALLEST PA
     $RTICLE AT INITIAL TIME DOES NOT MATCH GIVEN DERIVATIVE/9X,
     $48HNUMERICAL AND GIVEN DERIVATIVES RESPECTIVELY ARE,2E15.5)
   10 IF(TOUT(1).GT.0.D0)GO TO 57
      DO 63 I=1,NVART
      IF(A(I).LT.0.D0)GO TO 64
   63 CONTINUE
      GO TO 57
   64 ISTOP=1
      WRITE(IPRNT,58)X(I)
   58 FORMAT(54H0---INITIAL DISTRIBUTION NEGATIVE FOR A PARTICLE SIZE=,
     $  E12.4)
   57 CALL BETA(1,TOUT(1),XA,XB,R1)
      CALL BETA(1,TOUT(1),XB,XA,R2)
      IF(ABS(R1-R2)*1000..LE.ABS(R1))GO TO 50
      ISTOP=1
      WRITE(IPRNT,7)
    7 FORMAT(33H0---BETA ROUTINE IS NOT SYMMETRIC)
   50 IF(R1.GT.0..AND.R2.GT.0.D0)GO TO 17
      ISTOP=1
      WRITE(IPRNT,4)
    4 FORMAT(32H0---BETA ROUTINE IS NOT POSITIVE)
   17 IF(R1.EQ.0.OR.R2.EQ.0)WRITE(IPRNT,61)
   61 FORMAT(86H0---FOR PROBLEMS WITH NO COAGULATION IT IS BETTER TO USE
     $ THE METHOD OF CHARACTERISTICS/
     $  60H   REF. J. COLLOID AND INTERFACE SCIENCE, V.68, P.173 (1979))
C
C      **************************************************************
C      CHECK QUANTITIES ASSOCIATED WITH THE DISCRETE-CONTINUOUS G-D-E
C      **************************************************************
C
      IF(NDISCR.EQ.0)GO TO 5
      CALL EVAP(1,TOUT(1),XMEAN,R1)
      CALL EVAP(1,TOUT(1),XA,R2)
      CALL EVAP(1,TOUT(1),XB,R3)
      IF(R1.GE.0..AND.R2.GE.0..AND.R3.GE.0.D0)GO TO 55
      WRITE(IPRNT,56)
   56 FORMAT(28H0---EVAP ROUTINE IS NEGATIVE)
   55 IF(NDISCR.GE.2)GO TO 59
      ISTOP=1
      WRITE(IPRNT,60)
   60 FORMAT(90H0---IF THE DISCRETE CONTINUOUS EQUATIONS ARE USED, THERE
     $ MUST BE AT LEAST 2 DISCRETE SIZES)
   59 DO 46 I=NVARP1,NVART
      IF(A(I).GE.0.D0)GO TO 46
      ISTOP=1
      WRITE(IPRNT,47)I,A(I)
   47 FORMAT(20H0---MULTIPLET NUMBER,I4,23H HAS A CONCENTRATION OF,
     $  E13.4)
   46 CONTINUE
      DO 23 I=2,NMULP1
      IF(NDCLS(I).GT.NDISCR+1)GO TO 27
      ISTOP=1
      WRITE(IPRNT,29)I
   29 FORMAT(21H0---GRID POINT NUMBER,I3,78H HAS A MULTIPLET NUMBER LESS
     $ THAN OR EQUAL TO THE NUMBER OF DISCRETE SIZES + 1)
   27 IF(NDCLS(I).LE.2*NDISCR)GO TO 22
      ISTOP=1
      WRITE(IPRNT,8)I
    8 FORMAT(20H0---MULTIPLET NUMBER,I5,51H IS GREATER THAN TWICE THE NU
     $MBER OF DISCRETE SIZES)
   22 IF(NDCLS(I-1).LT.NDCLS(I))GO TO 23
      ISTOP=1
      WRITE(IPRNT,25)I-1,I
   25 FORMAT(21H0---MULTIPLET NUMBERS,I4,4H AND,I4,17H ARE OUT OF ORDER)
   23 CONTINUE
C
C               *****************
C               CHECK GRID POINTS
C               *****************
C
    5 IF(IGRID.EQ.0.AND.NDISCR.EQ.0)RETURN
      IF(W(2).GT.0..AND.W(NVARM1).LT.1.D0)GO TO 15
      WRITE(IPRNT,16)
   16 FORMAT(70H0---GRID POINTS MUST BE BETWEEN THE SMALLEST AND LARGEST
     $ PARTICLE SIZE)
      ISTOP=1
   15 IF(IABS(IGRID).LE.NVARM1-NMULP1)GO TO 38
      WRITE(IPRNT,39)
   39 FORMAT(93H0---NUMBER OF GRID POINTS GIVEN MUST BE LESS THAN OR EQU
     $AL TO THE NUMBER OF TOTAL GRID POINTS/9X,44HMINUS THE NUMBER OF MU
     $LTIPLETS GIVEN MINUS 2)
      ISTOP=1
   38 DO 12 I=2,NVARM1
      IF(W(I).GT.W(I-1))GO TO 12
      ISTOP=1
      WRITE(IPRNT,14)I
   14 FORMAT(54H0---GRID POINTS MUST BE IN ORDER, CHECK GRID POINT NO.,
     $I4)
   12 CONTINUE
      RETURN
      END
      SUBROUTINE DISTW(ISPLIN,NVARM1,NPTS,WX,ZDIST)
C-----------------------------------------------------------------------
C*    THIS FUNCTION COMPUTES THE VALUES OF THE M(WX,T) DISTRIBUTION    *
C*    BY INTERPOLATING FROM THE VALUES OF A AT THE GRID POINTS.        *
C*    NOTE THAT A(I) IS EQUAL TO THE 'M' DISTRIBUTION FUNCTION AT W(I) *
C*                                                                     *
C*            VARIABLES                                                *
C*                                                                     *
C*    M(WX,TIME)=N(X,TIME)*DERIVATIVE OF X WITH RESPECT TO WX          *
C*    NPTS=NUMBER OF POINTS IN WX ARRAY  (INPUT)                       *
C*    NVARM1=NUMBER OF GRID POINTS MINUS ONE  (INPUT)                  *
C*    WX=LN(X/XA)/LN(XB/XA)   (INPUT ARRAY)                            *
C*    X(I)=PARTICLE SIZE AT THE I-TH GRID POINT                        *
C*    P array contains the second derivatives at the grid points       *
C*    XA=SMALLEST PARTICLE SIZE IN CONTINUOUS REGIME                   *
C*    XB=LARGEST PARTICLE SIZE IN CONTINUOUS REGIME                    *
C*    ZDIST(I)=ARRAY OF M(WX,TIME)   (OUTPUT)                          *
C*                                                                     *
C*    INTERPOLATION METHOD                                             *
C*       ISPLIN=0  CUBIC SPLINES                                       *
C*                  REF. GERALD,C.F.,'APPLIED NUMERICAL ANALYSIS',     *
C*                       PP.474-488, ADDISON-WESLEY 1978               *
C*                       ALSO CARNAHAN,B., LUTHER,H.A., AND WILKES,J.O.*
C*                       'APPLIED NUMERICAL METHODS',P.63,WILEY 1969   *
C*              1  LINEAR SPLINES                                      *
C*              2  LOGARITHMIC SPLINES (POWER LAW)                     *
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION WX(1),ZDIST(1)
      COMMON/AERSL2/A(60),X(60),W(40)
      COMMON/AERSL7/P(38)
C
      DELTA(J)=W(J+1)-W(J)
C
C        DETERMINE BOUNDING GRID POINTS OF WX ASSUMING THAT THE POINTS
C        WX(I),I=1,NPTS ARE IN ASCENDING ORDER
C
      JSTART=1
      DO 3 I=1,NPTS
      DO 25 J=JSTART,NVARM1
      IF(WX(I).LE.W(J+1))GO TO 20
   25 CONTINUE
      J=NVARM1
   20 IF(ISPLIN.EQ.1)GO TO 1
      IF(ISPLIN.EQ.2)GO TO 2
C
C            CUBIC SPLINES
C
      IF(J.EQ.1)GO TO 30
      IF(J.EQ.NVARM1) GO TO 40
      ZDIST(I)=(P(J-1)*(W(J+1)-WX(I))**3+P(J)*(WX(I)-W(J))**3+(6.D0*A(J+        
     V1)
     $  -DELTA(J)**2*P(J))*(WX(I)-W(J))+(6.D0*A(J)-DELTA(J)**2*P(J-1))
     $  *(W(J+1)-WX(I)))/(6.D0*DELTA(J))
      GO TO 3
   30 ZDIST(I)=(P(J)*(WX(I)-W(J))**3+(6.D0*A(J+1)-DELTA(J)**2*P(J))*
     $  (WX(I)-W(J))+6.D0*A(J)*(W(J+1)-WX(I)))/(6.D0*DELTA(J))
      GO TO 3
   40 ZDIST(I)=(P(J-1)*(W(J+1)-WX(I))**3+6.D0*A(J+1)*(WX(I)-W(J))+(6.D0*        
     VA(J)
     $  -DELTA(J)**2*P(J-1))*(W(J+1)-WX(I)))/(6.D0*DELTA(J))
      GO TO 3
C
C            LINEAR SPLINES
C
    1 ZDIST(I)=A(J+1)+(WX(I)-W(J+1))/(W(J)-W(J+1))*(A(J)-A(J+1))
      GO TO 3
C
C            LOGARITHMIC SPLINES
C
    2 ZDIST(I)=DLOG(A(J+1))
      ZDIST(I)=ZDIST(I)+(WX(I)-W(J+1))/(W(J)-W(J+1))*
     $  (DLOG(A(J))-ZDIST(I))
      ZDIST(I)=EXP(ZDIST(I))
    3 JSTART=J
      RETURN
      END
      SUBROUTINE DERIVT(ISPLIN,NVAR,DERIV)
C-----------------------------------------------------------------------
C*    THIS FUNCTION CALCULATES THE DERIVATIVE OF THE 'M' DISTRIBUTION  *
C*    FUNCTION W.R.T. W, FOR THE NVAR GRID POINTS                      *
C*      REF. SEE REFERENCES TO ROUTINE DISTW                           *
C*                                                                     *
C*              VARIABLES                                              *
C*    A(I)='M' DISTRIBUTION AT W(I)                                    *
C*    DERIV=OUTPUT ARRAY OF DERIVATIVES AT GRID POINTS                 *
C*    NVAR=NUMBER OF GRID POINTS  (INPUT)                              *
C*    W(I)=LOGARITHMICALLY TRANSFORMED PARTICLE SIZE AT THE I-TH GRID  *
C*      POINT                                                          *
C*    X(I)=PARTICLE SIZE AT THE I-TH GRID POINT                        *
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION DERIV(1)
      COMMON/AERSL2/A(60),X(60),W(40)
      COMMON/AERSL7/P(38)
C
      DELTA(I)=W(I+1)-W(I)
C
      NVARM1=NVAR-1
      NVARM2=NVAR-2
      DERIV(1)=(A(2)-A(1))/DELTA(1)-DELTA(1)*P(1)/6.D0
      DO 1 I=2,NVARM2
    1 DERIV(I)=(A(I+1)-A(I))/DELTA(I)-DELTA(I)*(2.D0*P(I-1)+P(I))/6.D0
      DERIV(NVARM1)=(A(NVAR)-A(NVARM1))/DELTA(NVARM1)-DELTA(NVARM1)*
     $  P(NVARM2)/3.D0
      DERIV(NVAR)=DERIV(NVARM1)+0.5D0*DELTA(NVARM1)*P(NVARM2)
      RETURN
      END
      SUBROUTINE SETUP(ISPLIN,NEWSET,NVAR)
C-----------------------------------------------------------------------
C*    THIS ROUTINE IS USED FOR DETERMINING THE SECOND DERIVATIVE OF    *
C*    THE DISTRIBTUION AT THE GRID POINTS BY SOLVING A SYSTEM OF LINEAR*
C*    ALGEBRAIC EQUATIONS WITH A TRI-DIAGONAL COEFFICIENT MATRIX.      *
C*    THE ROUTINE IS REQUIRED FOR A CUBIC SPLINE INTERPOLATION.        *
C*    REFERENCE; CARNAHAN,B., LUTHER,H.A. AND WILKES,J.O. 'APPLIED     *
C*    NUMERICAL METHODS,' JOHN WILEY AND SONS, PAGE 446 (1969)         *
C*                                                                     *
C*               VARIABLES                                             *
C*                                                                     *
C*    DIAG(I)=THE I-TH DIAGONAL ELEMENT OF THE MATRIX                  *
C*    NEWSET=FLAG TO INDICATE A NEW SET OF GRID POINTS                 *
C*           0=SAME SET OF GRID POINTS                                 *
C*           1=NEW SET OF GRID POINTS                                  *
C*    P(I)=THE SECOND DERIVATIVE AT THE (I+1)-TH GRID POINT            *
C*    SUB(I)=THE (I-1)-TH SUB DIAGONAL ELEMENT OF THE MATRIX           *
C*    SUPER(I)=THE I-TH SUPER-DIAGONAL ELEMENT OF THE MATRIX           *
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION G(38),DIAG(38),SUB(38),SUPER(38)
      COMMON/AERSL2/A(60),X(60),W(40)
      COMMON/AERSL7/P(38)
C
      DELTA(I)=W(I+1)-W(I)
C
C        COMPUTE TRI-DIAGONAL MATRIX
C
      IF(NEWSET.EQ.0)GO TO 6
      NVARM2=NVAR-2
      NVARM3=NVARM2-1
      DO 1 I=1,NVARM2
      SUB(I)=DELTA(I)**2/6.D0
      SUPER(I)=DELTA(I)*DELTA(I+1)/6.D0
    1 DIAG(I)=2.D0*(SUB(I)+SUPER(I))
      DO 2 I=2,NVARM2
    2 DIAG(I)=DIAG(I)-SUB(I)*SUPER(I-1)/DIAG(I-1)
C
C        SOLVE THE LINEAR SYSTEM WITH THE TRI-DIAGONAL MATRIX
C
    6 DO 5 I=1,NVARM2
    5 P(I)=DELTA(I)*(A(I+2)-A(I+1))/DELTA(I+1)-A(I+1)+A(I)
      G(1)=P(1)/DIAG(1)
      DO 3 I=2,NVARM2
    3 G(I)=(P(I)-SUB(I)*G(I-1))/DIAG(I)
      P(NVARM2)=G(NVARM2)
      DO 4 J=1,NVARM3
      I=NVARM2-J
    4 P(I)=G(I)-SUPER(I)*P(I+1)/DIAG(I)
      RETURN
      END
      SUBROUTINE CSOURC(NPTS,TIME,V,DISTV,SOURCE,REMOVE)
C-----------------------------------------------------------------------
C*    THIS IS AN EXAMPLE OF A SOURCE AND/OR REMOVAL SUBROUTINE IN THE  *
C*    CONTINUOUS REGIME                                                *
C*                                                                     *
C*                  VARIABLES                                          *
C*                                                                     *
C*    DISTV(I)=THE DISTRIBUTION FUNCTION OF PARTICLE VOLUME OF THE I-TH*
C*      PARTICLE SIZE  (INPUT ARRAY IN  1/CC/CC)                       *
C*    GLSIG=NATURAL LOGARITHM OF THE GEOMETRIC STANDARD DEVIATION      *
C*    GMEAN=GEOMETRIC MEAN VOLUME  (CC)                                *
C*    REMOVE(J,I)=THE J-TH REMOVAL TERM  FOR THE I-TH PARTICLE SIZE    *
C*                (OUTPUT ARRAY IN 1/CC/SEC/CC)                        *
C*    SOURCE(J,I)=THE J-TH SOURCE TERM  FOR THE I-TH PARTICLE SIZE     *
C*                (OUTPUT ARRAY IN 1/CC/SEC/CC)                        *
C*    TIME=TIME (INPUT IN SEC)                                         *
C*    TOT=NUMBER PER CC                                                *
C*    V(I)=I-TH PARTICLE VOLUME  (INPUT ARRAY IN CC)                   *
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION V(1),DISTV(1),SOURCE(3,1),REMOVE(3,1)
        alnorm(tot,gmean,glsig)=.3989D0*tot*exp(-.5D0*(DLOG(v(i)
     1  /gmean)/glsig)**2)/(v(i)*glsig)
        do 1 i=1,npts
        source(1,i)=alnorm(100.D0,4.08D-19,1.22D0)
        source(2,i)=alnorm(1.D2,5.D-18,1.8D0)
        remove(1,i)=-5.D6*v(i)*exp(-.005D0*time)*distv(i)
1       remove(2,i)=-6.D4*v(i)*exp(-.01D0*time)*distv(i)
        return
        end
      SUBROUTINE DSOURC(NPTS,TIME,CLSCON,SOURCE,REMOVE)
C-----------------------------------------------------------------------
C*    THIS IS AN EXAMPLE OF A SOURCE AND/OR REMOVAL SUBROUTINE IN THE  *
C*    THE DISCRETE REGIME                                              *
C*                                                                     *
C*                    VARIABLES                                        *
C*                                                                     *
C*    CLSCON(I)=I-TH CLUSTER CONCENTRATION  (INPUT IN 1/CC)            *
C*    I=CLUSTER NUMBER  (INPUT)                                        *
C*    REMOVE(J,I)=THE J-TH REMOVAL TERM FOR THE I-TH CLUSTER (OUTPUT   *
C*      ARRAY IN 1/SEC/CC)                                             *
C*    SOURCE(J,I)=THE J-TH SOURCE TERM FOR THE I-TH CLUSTER  (OUTPUT   *
C*      ARRAY IN 1/SEC/CC)                                             *
C*    TIME=TIME  (INPUT IN SEC)                                        *
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION CLSCON(1),SOURCE(3,1),REMOVE(3,1)
        do 1 i=1,npts
        remove(1,i)=-1.D-2*clscon(i)
        remove(2,i)=-1.D-1*exp(-DBLE(i))*clscon(i)*exp(-.01D0*time)
        source(1,i)=0.D0
        source(2,i)=1.D3*exp(-DBLE(i))
        if(i.gt.1D0)go to 1
        source(1,i)=1.0D7
    1 CONTINUE
      RETURN
      END
      SUBROUTINE EVAP(NPTS,TIME,V,COEF)
C-----------------------------------------------------------------------
C*     THIS IS AN EXAMPLE OF A EVAPORATION FUNCTION SUBROUTINE         *
C*    REFS. SKINNER,L.M. AND SAMBLES,J.R., 'THE KELVIN EQUATION - A    *
C*    REVIEW', J. AEROSOL SCIENCE, VOL. 3, PP. 199-210 (1972) AND      *
C*    FRIEDLANDER,S.K., 'SMOKE, DUST AND HAZE', P.229, JOHN WILEY AND  *
C*    SONS, NEW YORK (1977)                                            *
C*                                                                     *
C*                    VARIABLES                                        *
C*                                                                     *
C*    BOLTZ=BOLTZMANN'S CONSTANT  (ERG/DEG K)                          *
C*    COEF(I)=EVAPORATION COEFFICIENT  (OUTPUT ARRAY IN 1/SEC)         *
C*    D=PARTICLE DIAMETER  (CM)                                        *
C*    EQNUM=EQUILIBRIUM NUMBER CONCENTRATION  (1/CC)                   *
C*    NPTS=NUMBER OF POINTS  (INPUT)                                   *
C*    surten=SURFACE TENSION  (DYNES/CM)                               *
C*    TEMPK=TEMPERATURE  (DEG K)                                       *
C*    TIME=TIME  (INPUT IN SEC)                                        *
C*    V(I)=PARTICLE VOLUME  (INPUT ARRAY IN CC)                        *
C*    VMOLEC=MOLECULAR VOLUME  (CC)                                    *
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION V(1),COEF(1)
        common/aersl1/iparm(10)
        data surten,vmolec,boltz,tempk,eqnum/70.D0,6.54D-23,1.38D-16
     1		,298.D0,1.D6/
        DO 1 I=1,NPTS
        coef(i)=0.D0
        if(iparm(1).eq.1D0)go to 1
        d=(1.9099D0*v(i))**.33333333333D0
        call beta(1,time,vmolec,v(i)-vmolec,coef(i))
        coef(i)=coef(i)*eqnum*exp(4.D0*surten*vmolec/(d*boltz*tempk))
1       continue
        return
        end
      SUBROUTINE ERRCHK(NCHARS,NARRAY)
C
C     SANDIA MATHEMATICAL PROGRAM LIBRARY
C     APPLIED MATHEMATICS DIVISION 2642
C     SANDIA LABORATORIES
C     ALBUQUERQUE, NEW MEXICO 87115
C
C     SIMPLIFIED VERSION FOR STAND-ALONE USE.     APRIL 1977
C
C     ABSTRACT
C         THE ROUTINES ERRCHK, ERXSET, AND ERRGET TOGETHER PROVIDE
C         A UNIFORM METHOD WITH SEVERAL OPTIONS FOR THE PROCESSING
C         OF DIAGNOSTICS AND WARNING MESSAGES WHICH ORIGINATE
C         IN THE MATHEMATICAL PROGRAM LIBRARY ROUTINES.
C         ERRCHK IS THE CENTRAL ROUTINE, WHICH ACTUALLY PROCESSES
C         MESSAGES.
C
C     DESCRIPTION OF ARGUMENTS
C         NCHARS - NUMBER OF CHARACTERS IN HOLLERITH MESSAGE.
C                  IF NCHARS IS NEGATED, ERRCHK WILL UNCONDITIONALLY
C                  PRINT THE MESSAGE AND STOP EXECUTION.  OTHERWISE,
C                  THE BEHAVIOR OF ERRCHK MAY BE CONTROLLED BY
C                  AN APPROPRIATE CALL TO ERXSET.
C         NARRAY - NAME OF ARRAY OR VARIABLE CONTAINING THE MESSAGE,
C                  OR ELSE A LITERAL HOLLERITH CONSTANT CONTAINING
C                  THE MESSAGE.  BY CONVENTION, ALL MESSAGES SHOULD
C                  BEGIN WITH *IN SUBNAM, ...*, WHERE SUBNAM IS THE
C                  NAME OF THE ROUTINE CALLING ERRCHK.
C
C     EXAMPLES
C         1. TO ALLOW CONTROL BY CALLING ERXSET, USE
C            CALL ERRCHK(30,30HIN QUAD, INVALID VALUE OF ERR.)
C         2. TO UNCONDITIONALLY PRINT A MESSAGE AND STOP EXECUTION, USE
C            CALL ERRCHK(-30,30HIN QUAD, INVALID VALUE OF ERR.)
C
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION NARRAY(14)
C
      CALL ERRGET(NF,NT)
C     IF ERRCHK WAS CALLED WITH NEGATIVE CHARACTER COUNT, SET FATAL FLAG
      IF (NCHARS.LT.0) NF = -1
C     IF MESSAGES ARE TO BE SUPPRESSED, RETURN
      IF (NF.EQ.0) RETURN
C     IF CHARACTER COUNT IS INVALID, STOP
      IF (NCHARS.EQ.0) PRINT 5
    5 FORMAT(/31H ERRCHK WAS CALLED INCORRECTLY.)
      IF (NCHARS.EQ.0) STOP
C     PRINT MESSAGE
      CALL ERRPRT(IABS(NCHARS),NARRAY)
C     IF LAST MESSAGE, SAY SO
      IF (NF.EQ.1) PRINT 10
   10 FORMAT (30H ERRCHK MESSAGE LIMIT REACHED.)
C     PRINT TRACE-BACK IF ASKED TO
C     IF ((NT.GT.0).OR.(NF.LT.0)) CALL SYSTEM ROUTINE FOR TRACEBACK
C     DECREMENT MESSAGE COUNT
      IF (NF.GT.0) NF = NF-1
      CALL ERXSET(NF,NT)
C     IF ALL IS WELL, RETURN
      IF (NF.GE.0) RETURN
C     IF THIS MESSAGE IS SUPPRESSABLE BY AN ERXSET CALL,
C     THEN EXPLAIN ERXSET USAGE.
      IF (NCHARS.GT.0) PRINT 15
   15 FORMAT (/13H *** NOTE ***
     1/53H TO MAKE THE ERROR MESSAGE PRINTED ABOVE BE NONFATAL,
     2/39H OR TO SUPPRESS THE MESSAGE COMPLETELY,
     3/37H INSERT AN APPROPRIATE CALL TO ERXSET ,
     4 30H AT THE START OF YOUR PROGRAM.
     5/62H FOR EXAMPLE, TO PRINT UP TO 10 NONFATAL WARNING MESSAGES, USE
     6/27H          CALL ERXSET(10,0)    )
      PRINT 20
   20 FORMAT (/28H PROGRAM ABORT DUE TO ERROR.)
      STOP
      END
      SUBROUTINE ONECHK(NCHARS,NARRAY)
C
C     ABSTRACT
C         ONECHK IS A COMPANION ROUTINE OF ERRCHK.  IT IS CALLED
C         JUST LIKE ERRCHK, AND MESSAGES FROM IT MAY BE SUPPRESSED
C         BY AN APPROPRIATE CALL TO ERXSET.  IT DIFFERS FROM ERRCHK
C         IN THAT EACH CALL TO ONECHK WILL PRODUCE NO MORE THAN ONE
C         PRINTED MESSAGE, REGARDLESS OF HOW MANY TIMES THAT CALL IS
C         EXECUTED, AND ONECHK NEVER TERMINATES EXECUTION.
C         ITS PURPOSE IS TO PROVIDE ONE-TIME-ONLY INFORMATIVE
C         DIAGNOSTICS.
C
C     DESCRIPTION OF ARGUMENTS
C         NCHARS - NUMBER OF CHARACTERS IN THE MESSAGE.
C                  IF NEGATED, THE MESSAGE WILL BE PRINTED (ONCE) EVEN
C                  IF NFATAL HAS BEEN SET TO 0 (SEE ERXSET).
C         NARRAY - SAME AS IN ERRCHK
C
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION NARRAY(14)
      DATA NFLAG/4H.$,*/
      IF (NARRAY(1).EQ.NFLAG) RETURN
      CALL ERRGET(NF,NT)
      IF ((NF.EQ.0).AND.(NCHARS.GT.0)) RETURN
      CALL ERRPRT (59,59HTHE FOLLOWING INFORMATIVE DIAGNOSTIC WILL APPEA
     1R ONLY ONCE.)
      CALL ERRPRT(IABS(NCHARS),NARRAY)
      IF (NF.GT.0) NF = NF-1
      CALL ERXSET(NF,NT)
      NARRAY(1) = NFLAG
      END
      SUBROUTINE ERRPRT(NCHARS,NARRAY)
C
C     UTILITY ROUTINE TO SIMPLY PRINT THE HOLLERITH MESSAGE IN NARRAY,
C     WHOSE LENGTH IS NCHARS CHARACTERS.
C
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION NARRAY(14)
C
C     NOTE - NCH MUST BE THE NUMBER OF HOLLERITH CHARACTERS STORED
C     PER WORD.  IF NCH IS CHANGED, FORMAT 1 MUST ALSO BE
C     CHANGED CORRESPONDINGLY.
C
      NCH = 10
C     FOR LINE PRINTERS, USE
    1 FORMAT (1X,13A10)
C     FOR DATA TERMINALS, USE
C   1 FORMAT (1X,7A10)
      NWORDS = (NCHARS+NCH-1)/NCH
      PRINT 1,(NARRAY(I),I=1,NWORDS)
      RETURN
      END
      SUBROUTINE ERXSET(NFATAL,NTRACE)
C
C     ABSTRACT
C         ERXSET IS A COMPANION ROUTINE TO SUBROUTINE ERRCHK.
C         ERXSET ASSIGNS THE VALUES OF NFATAL AND NTRACE RESPECTIVELY
C         TO NF AND NT IN COMMON BLOCK MLBLK0 THEREBY SPECIFYING THE
C         STATE OF THE OPTIONS WHICH CONTROL THE EXECUTION OF ERRCHK.
C
C     DESCRIPTION OF ARGUMENTS
C         BOTH ARGUMENTS ARE INPUT ARGUMENTS OF DATA TYPE INTEGER.
C         NFATAL - IS A FATAL-ERROR / MESSAGE-LIMIT FLAG. A NEGATIVE
C                  VALUE DENOTES THAT DETECTED DIFFICULTIES ARE TO BE
C                  TREATED AS FATAL ERRORS.  NONNEGATIVE MEANS NONFATAL.
C                  A NONNEGATIVE VALUE IS THE MAXIMUM NUMBER OF NONFATAL
C                  WARNING MESSAGES WHICH WILL BE PRINTED BY ERRCHK,
C                  AFTER WHICH NONFATAL MESSAGES WILL NOT BE PRINTED.
C                  (DEFAULT VALUE IS -1.)
C         NTRACE - .GE.1 WILL CAUSE A TRACE-BACK TO BE GIVEN,
C                        IF THIS FEATURE IS IMPLEMENTED ON THIS SYSTEM.
C                  .LE.0 WILL SUPPRESS ANY TRACE-BACK, EXCEPT FOR
C                        CASES WHEN EXECUTION IS TERMINATED.
C                  (DEFAULT VALUE IS 0.)
C
C         *NOTE* -- SOME CALLS TO ERRCHK WILL CAUSE UNCONDITIONAL
C         TERMINATION OF EXECUTION.  ERXSET HAS NO EFFECT ON SUCH CALLS.
C
C     EXAMPLES
C         1. TO PRINT UP TO 100 MESSAGES AS NONFATAL WARNINGS USE
C            CALL ERXSET(100,0)
C         2. TO SUPPRESS ALL MATHLIB WARNING MESSAGES USE
C            CALL ERXSET(0,0)
C
      IMPLICIT REAL*8 (A-H,O-Z)
      CALL ERSTGT(0,NFATAL,NTRACE)
      RETURN
      END
      SUBROUTINE ERRGET(NFATAL,NTRACE)
C
C     ABSTRACT
C         ERRGET IS A COMPANION ROUTINE TO SUBROUTINE ERRCHK.
C         ERRGET ASSIGNS TO NFATAL AND NTRACE RESPECTIVELY THE VALUES
C         OF NF AND NT IN COMMON BLOCK MLBLK0 THEREBY ASCERTAINING THE
C         STATE OF THE OPTIONS WHICH CONTROL THE EXECUTION OF ERRCHK.
C
C     DESCRIPTION OF ARGUMENTS
C         BOTH ARGUMENTS ARE OUTPUT ARGUMENTS OF DATA TYPE INTEGER.
C         NFATAL - CURRENT VALUE OF NF (SEE DESCRIPTION OF ERXSET.)
C         NTRACE - CURRENT VALUE OF NT (SEE DESCRIPTION OF ERXSET.)
C
      IMPLICIT REAL*8 (A-H,O-Z)
      CALL ERSTGT(1,NFATAL,NTRACE)
      RETURN
      END
      SUBROUTINE ERSTGT(K,NFATAL,NTRACE)
C
C     THIS ROUTINE IS A SLAVE TO ERRGET AND ERRSET WHICH KEEPS
C     THE FLAGS AS LOCAL VARIABLES.
C
C     *** IF LOCAL VARIABLES ARE NOT NORMALLY RETAINED BETWEEN
C     CALLS ON THIS SYSTEM, THE VARIABLES LNF AND LNT CAN BE
C     PLACED IN A COMMON BLOCK AND PRESET TO THE FOLLOWING
C     VALUES IN THE MAIN PROGRAM.
C
      IMPLICIT REAL*8 (A-H,O-Z)
      DATA LNF/-1/,LNT/0/
      IF (K.LE.0) LNF = NFATAL
      IF (K.LE.0) LNT = NTRACE
      IF (K.GT.0) NFATAL = LNF
      IF (K.GT.0) NTRACE = LNT
      RETURN
      END
      SUBROUTINE ODE(F,NEQN,Y,T,TOUT,RELERR,ABSERR,IFLAG,WORK,IWORK)
C
C     SANDIA MATHEMATICAL PROGRAM LIBRARY
C     APPLIED MATHEMATICS DIVISION 2613
C     SANDIA LABORATORIES
C     ALBUQUERQUE, NEW MEXICO  87185
C     CONTROL DATA 6600/7600  VERSION 7.2  MAY 1978
C  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C                    ISSUED BY SANDIA LABORATORIES                     *
C  *                   A PRIME CONTRACTOR TO THE                       *
C  *                UNITED STATES DEPARTMENT OF ENERGY                 *
C  * * * * * * * * * * * * * * * NOTICE  * * * * * * * * * * * * * * * *
C  * THIS REPORT WAS PREPARED AS AN ACCOUNT OF WORK SPONSORED BY THE   *
C  * UNITED STATES GOVERNMENT.  NEITHER THE UNITED STATES NOR THE      *
C  * UNITED STATES DEPARTMENT OF ENERGY NOR ANY OF THEIR EMPLOYEES,    *
C  * NOR ANY OF THEIR CONTRACTORS, SUBCONTRACTORS, OR THEIR EMPLOYEES  *
C  * MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL      *
C  * LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS OR     *
C  * USEFULNESS OF ANY INFORMATION, APPARATUS, PRODUCT OR PROCESS      *
C  * DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE          *
C  * OWNED RIGHTS.                                                     *
C  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C  * THE PRIMARY DOCUMENT FOR THE LIBRARY OF WHICH THIS ROUTINE IS     *
C  * PART IS SAND77-1441.                                              *
C  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C   WRITTEN BY L. F. SHAMPINE AND M. K. GORDON
C
C   ABSTRACT
C
C   SUBROUTINE  ODE  INTEGRATES A SYSTEM OF  NEQN  FIRST ORDER
C   ORDINARY DIFFERENTIAL EQUATIONS OF THE FORM
C             DY(I)/DT = F(T,Y(1),Y(2),...,Y(NEQN))
C             Y(I) GIVEN AT  T .
C   THE SUBROUTINE INTEGRATES FROM  T  TO  TOUT .  ON RETURN THE
C   PARAMETERS IN THE CALL LIST ARE SET FOR CONTINUING THE INTEGRATION.
C   THE USER HAS ONLY TO DEFINE A NEW VALUE  TOUT  AND CALL  ODE  AGAIN.
C
C   THE DIFFERENTIAL EQUATIONS ARE ACTUALLY SOLVED BY A SUITE OF CODES
C   DE ,  STEP1 , AND  INTRP .  ODE  ALLOCATES VIRTUAL STORAGE IN THE
C   ARRAYS  WORK  AND  IWORK  AND CALLS  DE .  DE  IS A SUPERVISOR WHICH
C   DIRECTS THE SOLUTION.  IT CALLS ON THE ROUTINES  STEP1  AND  INTRP
C   TO ADVANCE THE INTEGRATION AND TO INTERPOLATE AT OUTPUT POINTS.
C   STEP1  USES A MODIFIED DIVIDED DIFFERENCE FORM OF THE ADAMS PECE
C   FORMULAS AND LOCAL EXTRAPOLATION.  IT ADJUSTS THE ORDER AND STEP
C   SIZE TO CONTROL THE LOCAL ERROR PER UNIT STEP IN A GENERALIZED
C   SENSE.  NORMALLY EACH CALL TO  STEP1  ADVANCES THE SOLUTION ONE STEP
C   IN THE DIRECTION OF  TOUT .  FOR REASONS OF EFFICIENCY  DE
C   INTEGRATES BEYOND  TOUT  INTERNALLY, THOUGH NEVER BEYOND
C   T+10*(TOUT-T), AND CALLS  INTRP  TO INTERPOLATE THE SOLUTION AT
C   TOUT .  AN OPTION IS PROVIDED TO STOP THE INTEGRATION AT  TOUT  BUT
C   IT SHOULD BE USED ONLY IF IT IS IMPOSSIBLE TO CONTINUE THE
C   INTEGRATION BEYOND  TOUT .
C
C   THIS CODE IS COMPLETELY EXPLAINED AND DOCUMENTED IN THE TEXT,
C   COMPUTER SOLUTION OF ORDINARY DIFFERENTIAL EQUATIONS, THE INITIAL
C   VALUE PROBLEM  BY L. F. SHAMPINE AND M. K. GORDON.
C   FOR USAGE DETAILS, ALSO SEE SLA-73-1060.
C
C   THE PARAMETERS REPRESENT --
C      F -- SUBROUTINE F(T,Y,YP) TO EVALUATE DERIVATIVES YP(I)=DY(I)/DT
C      NEQN -- NUMBER OF EQUATIONS TO BE INTEGRATED
C      Y(*) -- SOLUTION VECTOR AT  T
C      T -- INDEPENDENT VARIABLE
C      TOUT -- POINT AT WHICH SOLUTION IS DESIRED
C      RELERR,ABSERR -- RELATIVE AND ABSOLUTE ERROR TOLERANCES FOR LOCAL
C           ERROR TEST.  AT EACH STEP THE CODE REQUIRES
C             ABS(LOCAL ERROR) .LE. ABS(Y)*RELERR + ABSERR
C           FOR EACH COMPONENT OF THE LOCAL ERROR AND SOLUTION VECTORS
C      IFLAG -- INDICATES STATUS OF INTEGRATION
C      WORK(*),IWORK(*) -- ARRAYS TO HOLD INFORMATION INTERNAL TO CODE
C           WHICH IS NECESSARY FOR SUBSEQUENT CALLS
C
C   FIRST CALL TO ODE --
C
C   THE USER MUST PROVIDE STORAGE IN HIS CALLING PROGRAM FOR THE ARRAYS
C   IN THE CALL LIST,
C      Y(NEQN), WORK(100+21*NEQN), IWORK(5),
C   DECLARE  F  IN AN EXTERNAL STATEMENT, SUPPLY THE SUBROUTINE
C   F(T,Y,YP) TO EVALUATE
C      DY(I)/DT = YP(I) = F(T,Y(1),Y(2),...,Y(NEQN))
C   AND INITIALIZE THE PARAMETERS --
C      NEQN -- NUMBER OF EQUATIONS TO BE INTEGRATED
C      Y(*) -- VECTOR OF INITIAL CONDITIONS
C      T -- STARTING POINT OF INTEGRATION
C      TOUT -- POINT AT WHICH SOLUTION IS DESIRED
C      RELERR,ABSERR -- RELATIVE AND ABSOLUTE LOCAL ERROR TOLERANCES
C      IFLAG -- +1,-1.  INDICATOR TO INITIALIZE THE CODE.  NORMAL INPUT
C           IS +1.  THE USER SHOULD SET IFLAG=-1 ONLY IF IT IS
C           IMPOSSIBLE TO CONTINUE THE INTEGRATION BEYOND  TOUT .
C   ALL PARAMETERS EXCEPT  F ,  NEQN  AND  TOUT  MAY BE ALTERED BY THE
C   CODE ON OUTPUT SO MUST BE VARIABLES IN THE CALLING PROGRAM.
C
C   OUTPUT FROM  ODE  --
C
C      NEQN -- UNCHANGED
C      Y(*) -- SOLUTION AT  T
C      T -- LAST POINT REACHED IN INTEGRATION.  NORMAL RETURN HAS
C           T = TOUT .
C      TOUT -- UNCHANGED
C      RELERR,ABSERR -- NORMAL RETURN HAS TOLERANCES UNCHANGED.  IFLAG=3
C           SIGNALS TOLERANCES INCREASED
C      IFLAG = 2 -- NORMAL RETURN.  INTEGRATION REACHED  TOUT
C            = 3 -- INTEGRATION DID NOT REACH  TOUT  BECAUSE ERROR
C                   TOLERANCES TOO SMALL.  RELERR ,  ABSERR  INCREASED
C                   APPROPRIATELY FOR CONTINUING
C            = 4 -- INTEGRATION DID NOT REACH  TOUT  BECAUSE MORE THAN
C                   500 STEPS NEEDED
C            = 5 -- INTEGRATION DID NOT REACH  TOUT  BECAUSE EQUATIONS
C                   APPEAR TO BE STIFF
C            = 6 -- INTEGRATION DID NOT REACH  TOUT  BECAUSE SOLUTION
C                   VANISHED MAKING PURE RELATIVE ERROR IMPOSSIBLE.
C                   MUST USE NON-ZERO  ABSERR  TO CONTINUE.
C            = 7 -- INVALID INPUT PARAMETERS (FATAL ERROR)
C           THE VALUE OF  IFLAG  IS RETURNED NEGATIVE WHEN THE INPUT
C           VALUE IS NEGATIVE AND THE INTEGRATION DOES NOT REACH  TOUT ,
C           I.E., -3, -4, -5, -6.
C      WORK(*),IWORK(*) -- INFORMATION GENERALLY OF NO INTEREST TO THE
C           USER BUT NECESSARY FOR SUBSEQUENT CALLS.
C
C   SUBSEQUENT CALLS TO  ODE --
C
C   SUBROUTINE  ODE  RETURNS WITH ALL INFORMATION NEEDED TO CONTINUE
C   THE INTEGRATION.  IF THE INTEGRATION REACHED  TOUT , THE USER NEED
C   ONLY DEFINE A NEW  TOUT  AND CALL AGAIN.  IF THE INTEGRATION DID NOT
C   REACH  TOUT  AND THE USER WANTS TO CONTINUE, HE JUST CALLS AGAIN.
C   IN THE CASE  IFLAG=6 , THE USER MUST ALSO ALTER THE ERROR CRITERION.
C   THE OUTPUT VALUE OF  IFLAG  IS THE APPROPRIATE INPUT VALUE FOR
C   SUBSEQUENT CALLS.  THE ONLY SITUATION IN WHICH IT SHOULD BE ALTERED
C   IS TO STOP THE INTEGRATION INTERNALLY AT THE NEW  TOUT , I.E.,
C   CHANGE OUTPUT  IFLAG=2  TO INPUT  IFLAG=-2 .  ERROR TOLERANCES MAY
C   BE CHANGED BY THE USER BEFORE CONTINUING.  ALL OTHER PARAMETERS MUST
C   REMAIN UNCHANGED.
C
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL START,PHASE1,NORND
      DIMENSION Y(NEQN),WORK(1),IWORK(5)
      EXTERNAL F
      DATA IALPHA,IBETA,ISIG,IV,IW,IG,IPHASE,IPSI,IX,IH,IHOLD,ISTART,
     1  ITOLD,IDELSN/1,13,25,38,50,62,75,76,88,89,90,91,92,93/
      IYY = 100
      IWT = IYY + NEQN
      IP = IWT + NEQN
      IYP = IP + NEQN
      IYPOUT = IYP + NEQN
      IPHI = IYPOUT + NEQN
      IF(IABS(IFLAG) .LT. 2  .OR.  IABS(IFLAG) .GT. 6) GO TO 1
      START = WORK(ISTART) .GT. 0.0D0
      PHASE1 = WORK(IPHASE) .GT. 0.0D0
      NORND = IWORK(2) .NE. -1
 1    CALL DE(F,NEQN,Y,T,TOUT,RELERR,ABSERR,IFLAG,WORK(IYY),
     1  WORK(IWT),WORK(IP),WORK(IYP),WORK(IYPOUT),WORK(IPHI),
     2  WORK(IALPHA),WORK(IBETA),WORK(ISIG),WORK(IV),WORK(IW),WORK(IG),
     3  PHASE1,WORK(IPSI),WORK(IX),WORK(IH),WORK(IHOLD),START,
     4  WORK(ITOLD),WORK(IDELSN),IWORK(1),NORND,IWORK(3),IWORK(4),
     5  IWORK(5))
      WORK(ISTART) = -1.0D0
      IF(START) WORK(ISTART) = 1.0D0
      WORK(IPHASE) = -1.0D0
      IF(PHASE1) WORK(IPHASE) = 1.0D0
      IWORK(2) = -1
      IF(NORND) IWORK(2) = 1
      RETURN
      END
      SUBROUTINE DE(F,NEQN,Y,T,TOUT,RELERR,ABSERR,IFLAG,
     1  YY,WT,P,YP,YPOUT,PHI,ALPHA,BETA,SIG,V,W,G,PHASE1,PSI,X,H,HOLD,
     2  START,TOLD,DELSGN,NS,NORND,K,KOLD,ISNOLD)
C
C   ODE  MERELY ALLOCATES STORAGE FOR  DE  TO RELIEVE THE USER OF THE
C   INCONVENIENCE OF A LONG CALL LIST.  CONSEQUENTLY  DE  IS USED AS
C   DESCRIBED IN THE COMMENTS FOR  ODE .
C
C   THIS CODE IS COMPLETELY EXPLAINED AND DOCUMENTED IN THE TEXT,
C   COMPUTER SOLUTION OF ORDINARY DIFFERENTIAL EQUATIONS, THE INITIAL
C   VALUE PROBLEM  BY L. F. SHAMPINE AND M. K. GORDON.
C
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL STIFF,CRASH,START,PHASE1,NORND
      DIMENSION Y(NEQN),YY(NEQN),WT(NEQN),PHI(NEQN,16),P(NEQN),YP(NEQN),
     1  YPOUT(NEQN),PSI(12),ALPHA(12),BETA(12),SIG(13),V(12),W(12),G(13)
      EXTERNAL F
C
C***********************************************************************
C*  THE ONLY MACHINE DEPENDENT CONSTANT IS BASED ON THE MACHINE UNIT   *
C*  ROUNDOFF ERROR  U  WHICH IS THE SMALLEST POSITIVE NUMBER SUCH THAT *
C*  1.0+U .GT. 1.0 .  U  MUST BE CALCULATED AND  FOURU=4.0*U  INSERTED *
C*  IN THE FOLLOWING DATA STATEMENT BEFORE USING  DE .  THE ROUTINE    *
C*  MACHIN  CALCULATES  U .  FOURU  AND  TWOU=2.0*U  MUST ALSO BE      *
C*  INSERTED IN SUBROUTINE  STEP1 BEFORE CALLING  DE .                 *
      DATA FOURU/3.08D-8/
C***********************************************************************
C
C   THE CONSTANT  MAXNUM  IS THE MAXIMUM NUMBER OF STEPS ALLOWED IN ONE
C   CALL TO  DE .  THE USER MAY CHANGE THIS LIMIT BY ALTERING THE
C   FOLLOWING STATEMENT
      DATA MAXNUM/500/
C
C            ***            ***            ***
C   TEST FOR IMPROPER PARAMETERS
C
      IF(NEQN .LT. 1) GO TO 10
      IF(T .EQ. TOUT) GO TO 10
      IF(RELERR .LT. 0.0  .OR.  ABSERR .LT. 0.0D0) GO TO 10
      EPS = DMAX1(RELERR,ABSERR)
      IF(EPS .LE. 0.0D0) GO TO 10
      IF(IFLAG .EQ. 0) GO TO 10
      ISN = ISIGN(1,IFLAG)
      IFLAG = IABS(IFLAG)
      IF(IFLAG .EQ. 1) GO TO 20
      IF(T .NE. TOLD) GO TO 10
      IF(IFLAG .GE. 2  .AND.  IFLAG .LE. 5) GO TO 20
      IF(IFLAG .EQ. 6  .AND.  ABSERR .GT. 0.0D0) GO TO 20
      IF(IFLAG .NE. 6  .AND.  IFLAG .NE. 7) GO TO 10
      IF(IFLAG .EQ. 6)CALL ERRCHK(-78,78HIN ODE   , IFLAG = 6 AND ABSERR
     1 NON-POSITIVE ON INPUT -- EXECUTION TERMINATED.)
      IF(IFLAG .EQ. 7)CALL ERRCHK(-54,54HIN ODE   , IFLAG = 7 ON INPUT -
     1- EXECUTION TERMINATED.)
      RETURN
 10   IFLAG = 7
      CALL ERRCHK(36,36HIN ODE   , INVALID INPUT PARAMETERS.)
      RETURN
C
C   ON EACH CALL SET INTERVAL OF INTEGRATION AND COUNTER FOR NUMBER OF
C   STEPS.  ADJUST INPUT ERROR TOLERANCES TO DEFINE WEIGHT VECTOR FOR
C   SUBROUTINE  STEP1
C
 20   DEL = TOUT - T
      ABSDEL = ABS(DEL)
      TEND = T + 10.0D0*DEL
      IF(ISN .LT. 0) TEND = TOUT
      NOSTEP = 0
      KLE4 = 0
      STIFF = .FALSE.
      RELEPS = RELERR/EPS
      ABSEPS = ABSERR/EPS
      IF(IFLAG .EQ. 1) GO TO 30
      IF(ISNOLD .LT. 0) GO TO 30
      IF(DELSGN*DEL .GT. 0.0D0) GO TO 50
C
C   ON START AND RESTART ALSO SET WORK VARIABLES X AND YY(*), STORE THE
C   DIRECTION OF INTEGRATION AND INITIALIZE THE STEP SIZE
C
 30   START = .TRUE.
      X = T
      DO 40 L = 1,NEQN
 40     YY(L) = Y(L)
      DELSGN = DSIGN(1.0D0,DEL)
      H = DSIGN(DMAX1(FOURU*ABS(X),ABS(TOUT-X)),TOUT-X)
C
C   IF ALREADY PAST OUTPUT POINT, INTERPOLATE AND RETURN
C
 50   IF(ABS(X-T) .LT. ABSDEL) GO TO 60
      CALL INTRP(X,YY,TOUT,Y,YPOUT,NEQN,KOLD,PHI,PSI)
      IFLAG = 2
      T = TOUT
      TOLD = T
      ISNOLD = ISN
      RETURN
C
C   IF CANNOT GO PAST OUTPUT POINT AND SUFFICIENTLY CLOSE,
C   EXTRAPOLATE AND RETURN
C
 60   IF(ISN .GT. 0  .OR.  ABS(TOUT-X) .GE. FOURU*ABS(X)) GO TO 80
      H = TOUT - X
      CALL F(X,YY,YP)
      DO 70 L = 1,NEQN
 70     Y(L) = YY(L) + H*YP(L)
      IFLAG = 2
      T = TOUT
      TOLD = T
      ISNOLD = ISN
      RETURN
C
C   TEST FOR TOO MANY STEPS
C
 80   IF(NOSTEP .LT. MAXNUM) GO TO 100
      IFLAG = ISN*4
      IF(STIFF) IFLAG = ISN*5
      DO 90 L = 1,NEQN
 90     Y(L) = YY(L)
      T = X
      TOLD = T
      ISNOLD = 1
      RETURN
C
C   LIMIT STEP SIZE, SET WEIGHT VECTOR AND TAKE A STEP
C
 100  H = DSIGN(DMIN1(ABS(H),ABS(TEND-X)),H)
      DO 110 L = 1,NEQN
        WT(L) = RELEPS*ABS(YY(L)) + ABSEPS
        IF(WT(L) .LE. 0.0D0) GO TO 140
 110    CONTINUE
      CALL STEP1(F,NEQN,YY,X,H,EPS,WT,START,
     1  HOLD,K,KOLD,CRASH,PHI,P,YP,PSI,
     2  ALPHA,BETA,SIG,V,W,G,PHASE1,NS,NORND)
C
C   TEST FOR TOLERANCES TOO SMALL
C
      IF(.NOT.CRASH) GO TO 130
      IFLAG = ISN*3
      RELERR = EPS*RELEPS
      ABSERR = EPS*ABSEPS
      DO 120 L = 1,NEQN
 120    Y(L) = YY(L)
      T = X
      TOLD = T
      ISNOLD = 1
      RETURN
C
C   AUGMENT COUNTER ON NUMBER OF STEPS AND TEST FOR STIFFNESS
C
 130  NOSTEP = NOSTEP + 1
      KLE4 = KLE4 + 1
      IF(KOLD .GT. 4) KLE4 = 0
      IF(KLE4 .GE. 50) STIFF = .TRUE.
      GO TO 50
C
C   RELATIVE ERROR CRITERION INAPPROPRIATE
C
 140  IFLAG = ISN*6
      DO 150 L = 1,NEQN
 150    Y(L) = YY(L)
      T = X
      TOLD = T
      ISNOLD = 1
      CALL ERRCHK(97,97HIN ODE   , PURE RELATIVE ERROR IMPOSSIBLE WHEN S
     1OLUTION VANISHES.  USE A NON-ZERO VALUE OF ABSERR)
      RETURN
      END
      SUBROUTINE STEP1(F,NEQN,Y,X,H,EPS,WT,START,
     1 HOLD,K,KOLD,CRASH,PHI,P,YP,PSI,
     2 ALPHA,BETA,SIG,V,W,G,PHASE1,NS,NORND)
C
C     SANDIA MATHEMATICAL PROGRAM LIBRARY
C     APPLIED MATHEMATICS DIVISION 2613
C     SANDIA LABORATORIES
C     ALBUQUERQUE, NEW MEXICO  87185
C     CONTROL DATA 6600/7600  VERSION 7.2  MAY 1978
C  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C                    ISSUED BY SANDIA LABORATORIES                     *
C  *                   A PRIME CONTRACTOR TO THE                       *
C  *                UNITED STATES DEPARTMENT OF ENERGY                 *
C  * * * * * * * * * * * * * * * NOTICE  * * * * * * * * * * * * * * * *
C  * THIS REPORT WAS PREPARED AS AN ACCOUNT OF WORK SPONSORED BY THE   *
C  * UNITED STATES GOVERNMENT.  NEITHER THE UNITED STATES NOR THE      *
C  * UNITED STATES DEPARTMENT OF ENERGY NOR ANY OF THEIR EMPLOYEES,    *
C  * NOR ANY OF THEIR CONTRACTORS, SUBCONTRACTORS, OR THEIR EMPLOYEES  *
C  * MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL      *
C  * LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS OR     *
C  * USEFULNESS OF ANY INFORMATION, APPARATUS, PRODUCT OR PROCESS      *
C  * DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE          *
C  * OWNED RIGHTS.                                                     *
C  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C  * THE PRIMARY DOCUMENT FOR THE LIBRARY OF WHICH THIS ROUTINE IS     *
C  * PART IS SAND77-1441.                                              *
C  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C   WRITTEN BY L. F. SHAMPINE AND M. K. GORDON
C
C   ABSTRACT
C
C   SUBROUTINE  STEP1  IS NORMALLY USED INDIRECTLY THROUGH SUBROUTINE
C   ODE .  BECAUSE  ODE  SUFFICES FOR MOST PROBLEMS AND IS MUCH EASIER
C   TO USE, USING IT SHOULD BE CONSIDERED BEFORE USING  STEP1  ALONE.
C
C   SUBROUTINE STEP1 INTEGRATES A SYSTEM OF  NEQN  FIRST ORDER ORDINARY
C   DIFFERENTIAL EQUATIONS ONE STEP, NORMALLY FROM X TO X+H, USING A
C   MODIFIED DIVIDED DIFFERENCE FORM OF THE ADAMS PECE FORMULAS.  LOCAL
C   EXTRAPOLATION IS USED TO IMPROVE ABSOLUTE STABILITY AND ACCURACY.
C   THE CODE ADJUSTS ITS ORDER AND STEP SIZE TO CONTROL THE LOCAL ERROR
C   PER UNIT STEP IN A GENERALIZED SENSE.  SPECIAL DEVICES ARE INCLUDED
C   TO CONTROL ROUNDOFF ERROR AND TO DETECT WHEN THE USER IS REQUESTING
C   TOO MUCH ACCURACY.
C
C   THIS CODE IS COMPLETELY EXPLAINED AND DOCUMENTED IN THE TEXT,
C   COMPUTER SOLUTION OF ORDINARY DIFFERENTIAL EQUATIONS, THE INITIAL
C   VALUE PROBLEM  BY L. F. SHAMPINE AND M. K. GORDON.
C   FURTHER DETAILS ON USE OF THIS CODE ARE AVAILABLE IN *SOLVING
C   ORDINARY DIFFERENTIAL EQUATIONS WITH ODE, STEP, AND INTRP*,
C   BY L. F. SHAMPINE AND M. K. GORDON, SLA-73-1060.
C
C
C   THE PARAMETERS REPRESENT --
C      F -- SUBROUTINE TO EVALUATE DERIVATIVES
C      NEQN -- NUMBER OF EQUATIONS TO BE INTEGRATED
C      Y(*) -- SOLUTION VECTOR AT X
C      X -- INDEPENDENT VARIABLE
C      H -- APPROPRIATE STEP SIZE FOR NEXT STEP.  NORMALLY DETERMINED BY
C           CODE
C      EPS -- LOCAL ERROR TOLERANCE
C      WT(*) -- VECTOR OF WEIGHTS FOR ERROR CRITERION
C      START -- LOGICAL VARIABLE SET .TRUE. FOR FIRST STEP,  .FALSE.
C           OTHERWISE
C      HOLD -- STEP SIZE USED FOR LAST SUCCESSFUL STEP
C      K -- APPROPRIATE ORDER FOR NEXT STEP (DETERMINED BY CODE)
C      KOLD -- ORDER USED FOR LAST SUCCESSFUL STEP
C      CRASH -- LOGICAL VARIABLE SET .TRUE. WHEN NO STEP CAN BE TAKEN,
C           .FALSE. OTHERWISE.
C      YP(*) -- DERIVATIVE OF SOLUTION VECTOR AT  X  AFTER SUCCESSFUL
C           STEP
C   THE ARRAYS  PHI, PSI  ARE REQUIRED FOR THE INTERPOLATION SUBROUTINE
C   INTRP .  THE ARRAY  P  IS INTERNAL TO THE CODE.  THE REMAINING NINE
C   VARIABLES AND ARRAYS ARE INCLUDED IN THE CALL LIST ONLY TO ELIMINATE
C   LOCAL RETENTION OF VARIABLES BETWEEN CALLS.
C
C   INPUT TO STEP1
C
C      FIRST CALL --
C
C   THE USER MUST PROVIDE STORAGE IN HIS CALLING PROGRAM FOR ALL ARRAYS
C   IN THE CALL LIST, NAMELY
C
C     DIMENSION Y(NEQN),WT(NEQN),PHI(NEQN,16),P(NEQN),YP(NEQN),PSI(12),
C    1  ALPHA(12),BETA(12),SIG(13),V(12),W(12),G(13)
C                              --                --    **NOTE**
C
C   THE USER MUST ALSO DECLARE  START ,  CRASH ,  PHASE1  AND  NORND
C   LOGICAL VARIABLES AND  F  AN EXTERNAL SUBROUTINE, SUPPLY THE
C   SUBROUTINE  F(X,Y,YP)  TO EVALUATE
C      DY(I)/DX = YP(I) = F(X,Y(1),Y(2),...,Y(NEQN))
C   AND INITIALIZE ONLY THE FOLLOWING PARAMETERS.
C      NEQN -- NUMBER OF EQUATIONS TO BE INTEGRATED
C      Y(*) -- VECTOR OF INITIAL VALUES OF DEPENDENT VARIABLES
C      X -- INITIAL VALUE OF THE INDEPENDENT VARIABLE
C      H -- NOMINAL STEP SIZE INDICATING DIRECTION OF INTEGRATION
C           AND MAXIMUM SIZE OF STEP.  MUST BE VARIABLE
C      EPS -- LOCAL ERROR TOLERANCE PER STEP.  MUST BE VARIABLE
C      WT(*) -- VECTOR OF NON-ZERO WEIGHTS FOR ERROR CRITERION
C      START -- .TRUE.
C
C   STEP1  REQUIRES THAT THE L2 NORM OF THE VECTOR WITH COMPONENTS
C   LOCAL ERROR(L)/WT(L)  BE LESS THAN  EPS  FOR A SUCCESSFUL STEP.  THE
C   ARRAY  WT  ALLOWS THE USER TO SPECIFY AN ERROR TEST APPROPRIATE
C   FOR HIS PROBLEM.  FOR EXAMPLE,
C      WT(L) = 1.0  SPECIFIES ABSOLUTE ERROR,
C            = ABS(Y(L))  ERROR RELATIVE TO THE MOST RECENT VALUE OF THE
C                 L-TH COMPONENT OF THE SOLUTION,
C            = ABS(YP(L))  ERROR RELATIVE TO THE MOST RECENT VALUE OF
C                 THE L-TH COMPONENT OF THE DERIVATIVE,
C            = AMAX1(WT(L),ABS(Y(L)))  ERROR RELATIVE TO THE LARGEST
C                 MAGNITUDE OF L-TH COMPONENT OBTAINED SO FAR,
C            = ABS(Y(L))*RELERR/EPS + ABSERR/EPS  SPECIFIES A MIXED
C                 RELATIVE-ABSOLUTE TEST WHERE  RELERR  IS RELATIVE
C                 ERROR,  ABSERR  IS ABSOLUTE ERROR AND  EPS =
C                 AMAX1(RELERR,ABSERR) .
C
C      SUBSEQUENT CALLS --
C
C   SUBROUTINE  STEP1  IS DESIGNED SO THAT ALL INFORMATION NEEDED TO
C   CONTINUE THE INTEGRATION, INCLUDING THE STEP SIZE  H  AND THE ORDER
C   K , IS RETURNED WITH EACH STEP.  WITH THE EXCEPTION OF THE STEP
C   SIZE, THE ERROR TOLERANCE, AND THE WEIGHTS, NONE OF THE PARAMETERS
C   SHOULD BE ALTERED.  THE ARRAY  WT  MUST BE UPDATED AFTER EACH STEP
C   TO MAINTAIN RELATIVE ERROR TESTS LIKE THOSE ABOVE.  NORMALLY THE
C   INTEGRATION IS CONTINUED JUST BEYOND THE DESIRED ENDPOINT AND THE
C   SOLUTION INTERPOLATED THERE WITH SUBROUTINE  INTRP .  IF IT IS
C   IMPOSSIBLE TO INTEGRATE BEYOND THE ENDPOINT, THE STEP SIZE MAY BE
C   REDUCED TO HIT THE ENDPOINT SINCE THE CODE WILL NOT TAKE A STEP
C   LARGER THAN THE  H  INPUT.  CHANGING THE DIRECTION OF INTEGRATION,
C   I.E., THE SIGN OF  H , REQUIRES THE USER SET  START = .TRUE. BEFORE
C   CALLING  STEP1  AGAIN.  THIS IS THE ONLY SITUATION IN WHICH  START
C   SHOULD BE ALTERED.
C
C   OUTPUT FROM STEP1
C
C      SUCCESSFUL STEP --
C
C   THE SUBROUTINE RETURNS AFTER EACH SUCCESSFUL STEP WITH  START  AND
C   CRASH  SET .FALSE. .  X  REPRESENTS THE INDEPENDENT VARIABLE
C   ADVANCED ONE STEP OF LENGTH  HOLD  FROM ITS VALUE ON INPUT AND  Y
C   THE SOLUTION VECTOR AT THE NEW VALUE OF  X .  ALL OTHER PARAMETERS
C   REPRESENT INFORMATION CORRESPONDING TO THE NEW  X  NEEDED TO
C   CONTINUE THE INTEGRATION.
C
C      UNSUCCESSFUL STEP --
C
C   WHEN THE ERROR TOLERANCE IS TOO SMALL FOR THE MACHINE PRECISION,
C   THE SUBROUTINE RETURNS WITHOUT TAKING A STEP AND  CRASH = .TRUE. .
C   AN APPROPRIATE STEP SIZE AND ERROR TOLERANCE FOR CONTINUING ARE
C   ESTIMATED AND ALL OTHER INFORMATION IS RESTORED AS UPON INPUT
C   BEFORE RETURNING.  TO CONTINUE WITH THE LARGER TOLERANCE, THE USER
C   JUST CALLS THE CODE AGAIN.  A RESTART IS NEITHER REQUIRED NOR
C   DESIRABLE.
C
      IMPLICIT REAL*8 (A-H,O-Z)
      LOGICAL START,CRASH,PHASE1,NORND
      DIMENSION Y(NEQN),WT(NEQN),PHI(NEQN,16),P(NEQN),YP(NEQN),PSI(12),
     1  ALPHA(12),BETA(12),SIG(13),V(12),W(12),G(13)
      DIMENSION TWO(13),GSTR(13)
      EXTERNAL F
C***********************************************************************
C*  THE ONLY MACHINE DEPENDENT CONSTANTS ARE BASED ON THE MACHINE UNIT *
C*  ROUNDOFF ERROR  U  WHICH IS THE SMALLEST POSITIVE NUMBER SUCH THAT *
C*  1.0+U .GT. 1.0  .  THE USER MUST CALCULATE  U  AND INSERT          *
C*  TWOU=2.0*U  AND  FOURU=4.0*U  IN THE DATA STATEMENT BEFORE CALLING *
C*  THE CODE.  THE ROUTINE  MACHIN  CALCULATES  U .                    *
      DATA TWOU,FOURU/1.54D-8,3.08D-8/
C***********************************************************************
C
      DATA TWO/2.0D0,4.0D0,8.0D0,16.0D0,32.0D0,64.0D0,128.0D0,256.0D0,51        
     V2.0D0,1024.0D0,
     1  2048.0D0,4096.0D0,8192.0D0/
      DATA GSTR/0.500D0,0.0833D0,0.0417D0,0.0264D0,0.0188D0,0.0143D0,0.0        
     V114,0.00936D0,
     1  0.00789D0,0.00679D0,0.00592D0,0.00524D0,0.00468D0/
C
C
C       ***     BEGIN BLOCK 0     ***
C   CHECK IF STEP SIZE OR ERROR TOLERANCE IS TOO SMALL FOR MACHINE
C   PRECISION.  IF FIRST STEP, INITIALIZE PHI ARRAY AND ESTIMATE A
C   STARTING STEP SIZE.
C                   ***
C
C   IF STEP SIZE IS TOO SMALL, DETERMINE AN ACCEPTABLE ONE
C
      CRASH = .TRUE.
      IF(ABS(H) .GE. FOURU*ABS(X)) GO TO 5
      H = DSIGN(FOURU*ABS(X),H)
      RETURN
 5    P5EPS = 0.5D0*EPS
C
C   IF ERROR TOLERANCE IS TOO SMALL, INCREASE IT TO AN ACCEPTABLE VALUE
C
      ROUND = 0.0D0
      DO 10 L = 1,NEQN
 10     ROUND = ROUND + (Y(L)/WT(L))**2
      ROUND = TWOU*SQRT(ROUND)
      IF(P5EPS .GE. ROUND) GO TO 15
      EPS = 2.0D0*ROUND*(1.0D0 + FOURU)
      RETURN
 15   CRASH = .FALSE.
      G(1) = 1.0D0
      G(2) = 0.5D0
      SIG(1) = 1.0D0
      IF(.NOT.START) GO TO 99
C
C   INITIALIZE.  COMPUTE APPROPRIATE STEP SIZE FOR FIRST STEP
C
      CALL F(X,Y,YP)
      SUM = 0.0D0
      DO 20 L = 1,NEQN
        PHI(L,1) = YP(L)
        PHI(L,2) = 0.0D0
 20     SUM = SUM + (YP(L)/WT(L))**2
      SUM = SQRT(SUM)
      ABSH = ABS(H)
      IF(EPS .LT. 16.0D0*SUM*H*H) ABSH = 0.25D0*SQRT(EPS/SUM)
      H = DSIGN(DMAX1(ABSH,FOURU*ABS(X)),H)
      HOLD = 0.0D0
      K = 1
      KOLD = 0
      START = .FALSE.
      PHASE1 = .TRUE.
      NORND = .TRUE.
      IF(P5EPS .GT. 100.0D0*ROUND) GO TO 99
      NORND = .FALSE.
      DO 25 L = 1,NEQN
 25     PHI(L,15) = 0.0D0
 99   IFAIL = 0
C       ***     END BLOCK 0     ***
C
C       ***     BEGIN BLOCK 1     ***
C   COMPUTE COEFFICIENTS OF FORMULAS FOR THIS STEP.  AVOID COMPUTING
C   THOSE QUANTITIES NOT CHANGED WHEN STEP SIZE IS NOT CHANGED.
C                   ***
C
 100  KP1 = K+1
      KP2 = K+2
      KM1 = K-1
      KM2 = K-2
C
C   NS IS THE NUMBER OF STEPS TAKEN WITH SIZE H, INCLUDING THE CURRENT
C   ONE.  WHEN K.LT.NS, NO COEFFICIENTS CHANGE
C
      IF(H .NE. HOLD) NS = 0
      IF (NS.LE.KOLD) NS = NS+1
      NSP1 = NS+1
      IF (K .LT. NS) GO TO 199
C
C   COMPUTE THOSE COMPONENTS OF ALPHA(*),BETA(*),PSI(*),SIG(*) WHICH
C   ARE CHANGED
C
      BETA(NS) = 1.0D0
      REALNS = NS
      ALPHA(NS) = 1.0D0/REALNS
      TEMP1 = H*REALNS
      SIG(NSP1) = 1.0D0
      IF(K .LT. NSP1) GO TO 110
      DO 105 I = NSP1,K
        IM1 = I-1
        TEMP2 = PSI(IM1)
        PSI(IM1) = TEMP1
        BETA(I) = BETA(IM1)*PSI(IM1)/TEMP2
        TEMP1 = TEMP2 + H
        ALPHA(I) = H/TEMP1
        REALI = I
 105    SIG(I+1) = REALI*ALPHA(I)*SIG(I)
 110  PSI(K) = TEMP1
C
C   COMPUTE COEFFICIENTS G(*)
C
C   INITIALIZE V(*) AND SET W(*).
C
      IF(NS .GT. 1) GO TO 120
      DO 115 IQ = 1,K
        TEMP3 = IQ*(IQ+1)
        V(IQ) = 1.0D0/TEMP3
 115    W(IQ) = V(IQ)
      GO TO 140
C
C   IF ORDER WAS RAISED, UPDATE DIAGONAL PART OF V(*)
C
 120  IF(K .LE. KOLD) GO TO 130
      TEMP4 = K*KP1
      V(K) = 1.0D0/TEMP4
      NSM2 = NS-2
      IF(NSM2 .LT. 1) GO TO 130
      DO 125 J = 1,NSM2
        I = K-J
 125    V(I) = V(I) - ALPHA(J+1)*V(I+1)
C
C   UPDATE V(*) AND SET W(*)
C
 130  LIMIT1 = KP1 - NS
      TEMP5 = ALPHA(NS)
      DO 135 IQ = 1,LIMIT1
        V(IQ) = V(IQ) - TEMP5*V(IQ+1)
 135    W(IQ) = V(IQ)
      G(NSP1) = W(1)
C
C   COMPUTE THE G(*) IN THE WORK VECTOR W(*)
C
 140  NSP2 = NS + 2
      IF(KP1 .LT. NSP2) GO TO 199
      DO 150 I = NSP2,KP1
        LIMIT2 = KP2 - I
        TEMP6 = ALPHA(I-1)
        DO 145 IQ = 1,LIMIT2
 145      W(IQ) = W(IQ) - TEMP6*W(IQ+1)
 150    G(I) = W(1)
 199    CONTINUE
C       ***     END BLOCK 1     ***
C
C       ***     BEGIN BLOCK 2     ***
C   PREDICT A SOLUTION P(*), EVALUATE DERIVATIVES USING PREDICTED
C   SOLUTION, ESTIMATE LOCAL ERROR AT ORDER K AND ERRORS AT ORDERS K,
C   K-1, K-2 AS IF CONSTANT STEP SIZE WERE USED.
C                   ***
C
C   CHANGE PHI TO PHI STAR
C
      IF(K .LT. NSP1) GO TO 215
      DO 210 I = NSP1,K
        TEMP1 = BETA(I)
        DO 205 L = 1,NEQN
 205      PHI(L,I) = TEMP1*PHI(L,I)
 210    CONTINUE
C
C   PREDICT SOLUTION AND DIFFERENCES
C
 215  DO 220 L = 1,NEQN
        PHI(L,KP2) = PHI(L,KP1)
        PHI(L,KP1) = 0.0D0
 220    P(L) = 0.0D0
      DO 230 J = 1,K
        I = KP1 - J
        IP1 = I+1
        TEMP2 = G(I)
        DO 225 L = 1,NEQN
          P(L) = P(L) + TEMP2*PHI(L,I)
 225      PHI(L,I) = PHI(L,I) + PHI(L,IP1)
 230    CONTINUE
      IF(NORND) GO TO 240
      DO 235 L = 1,NEQN
        TAU = H*P(L) - PHI(L,15)
        P(L) = Y(L) + TAU
 235    PHI(L,16) = (P(L) - Y(L)) - TAU
      GO TO 250
 240  DO 245 L = 1,NEQN
 245    P(L) = Y(L) + H*P(L)
 250  XOLD = X
      X = X + H
      ABSH = ABS(H)
      CALL F(X,P,YP)
C
C   ESTIMATE ERRORS AT ORDERS K,K-1,K-2
C
      ERKM2 = 0.0D0
      ERKM1 = 0.0D0
      ERK = 0.0D0
      DO 265 L = 1,NEQN
        TEMP3 = 1.0D0/WT(L)
        TEMP4 = YP(L) - PHI(L,1)
        IF(KM2)265,260,255
 255    ERKM2 = ERKM2 + ((PHI(L,KM1)+TEMP4)*TEMP3)**2
 260    ERKM1 = ERKM1 + ((PHI(L,K)+TEMP4)*TEMP3)**2
 265    ERK = ERK + (TEMP4*TEMP3)**2
      IF(KM2)280,275,270
 270  ERKM2 = ABSH*SIG(KM1)*GSTR(KM2)*SQRT(ERKM2)
 275  ERKM1 = ABSH*SIG(K)*GSTR(KM1)*SQRT(ERKM1)
 280  TEMP5 = ABSH*SQRT(ERK)
      ERR = TEMP5*(G(K)-G(KP1))
      ERK = TEMP5*SIG(KP1)*GSTR(K)
      KNEW = K
C
C   TEST IF ORDER SHOULD BE LOWERED
C
      IF(KM2)299,290,285
 285  IF(DMAX1(ERKM1,ERKM2) .LE. ERK) KNEW = KM1
      GO TO 299
 290  IF(ERKM1 .LE. 0.5D0*ERK) KNEW = KM1
C
C   TEST IF STEP SUCCESSFUL
C
 299  IF(ERR .LE. EPS) GO TO 400
C       ***     END BLOCK 2     ***
C
C       ***     BEGIN BLOCK 3     ***
C   THE STEP IS UNSUCCESSFUL.  RESTORE  X, PHI(*,*), PSI(*) .
C   IF THIRD CONSECUTIVE FAILURE, SET ORDER TO ONE.  IF STEP FAILS MORE
C   THAN THREE TIMES, CONSIDER AN OPTIMAL STEP SIZE.  DOUBLE ERROR
C   TOLERANCE AND RETURN IF ESTIMATED STEP SIZE IS TOO SMALL FOR MACHINE
C   PRECISION.
C                   ***
C
C   RESTORE X, PHI(*,*) AND PSI(*)
C
      PHASE1 = .FALSE.
      X = XOLD
      DO 310 I = 1,K
        TEMP1 = 1.0D0/BETA(I)
        IP1 = I+1
        DO 305 L = 1,NEQN
 305      PHI(L,I) = TEMP1*(PHI(L,I) - PHI(L,IP1))
 310    CONTINUE
      IF(K .LT. 2) GO TO 320
      DO 315 I = 2,K
 315    PSI(I-1) = PSI(I) - H
C
C   ON THIRD FAILURE, SET ORDER TO ONE.  THEREAFTER, USE OPTIMAL STEP
C   SIZE
C
 320  IFAIL = IFAIL + 1
      TEMP2 = 0.5D0
      IF(IFAIL - 3) 335,330,325
 325  IF(P5EPS .LT. 0.25D0*ERK) TEMP2 = SQRT(P5EPS/ERK)
 330  KNEW = 1
 335  H = TEMP2*H
      K = KNEW
      IF(ABS(H) .GE. FOURU*ABS(X)) GO TO 340
      CRASH = .TRUE.
      H = DSIGN(FOURU*ABS(X),H)
      EPS = EPS + EPS
      RETURN
 340  GO TO 100
C       ***     END BLOCK 3     ***
C
C       ***     BEGIN BLOCK 4     ***
C   THE STEP IS SUCCESSFUL.  CORRECT THE PREDICTED SOLUTION, EVALUATE
C   THE DERIVATIVES USING THE CORRECTED SOLUTION AND UPDATE THE
C   DIFFERENCES.  DETERMINE BEST ORDER AND STEP SIZE FOR NEXT STEP.
C                   ***
 400  KOLD = K
      HOLD = H
C
C   CORRECT AND EVALUATE
C
      TEMP1 = H*G(KP1)
      IF(NORND) GO TO 410
      DO 405 L = 1,NEQN
        RHO = TEMP1*(YP(L) - PHI(L,1)) - PHI(L,16)
        Y(L) = P(L) + RHO
 405    PHI(L,15) = (Y(L) - P(L)) - RHO
      GO TO 420
 410  DO 415 L = 1,NEQN
 415    Y(L) = P(L) + TEMP1*(YP(L) - PHI(L,1))
 420  CALL F(X,Y,YP)
C
C   UPDATE DIFFERENCES FOR NEXT STEP
C
      DO 425 L = 1,NEQN
        PHI(L,KP1) = YP(L) - PHI(L,1)
 425    PHI(L,KP2) = PHI(L,KP1) - PHI(L,KP2)
      DO 435 I = 1,K
        DO 430 L = 1,NEQN
 430      PHI(L,I) = PHI(L,I) + PHI(L,KP1)
 435    CONTINUE
C
C   ESTIMATE ERROR AT ORDER K+1 UNLESS:
C     IN FIRST PHASE WHEN ALWAYS RAISE ORDER,
C     ALREADY DECIDED TO LOWER ORDER,
C     STEP SIZE NOT CONSTANT SO ESTIMATE UNRELIABLE
C
      ERKP1 = 0.0D0
      IF(KNEW .EQ. KM1  .OR.  K .EQ. 12) PHASE1 = .FALSE.
      IF(PHASE1) GO TO 450
      IF(KNEW .EQ. KM1) GO TO 455
      IF(KP1 .GT. NS) GO TO 460
      DO 440 L = 1,NEQN
 440    ERKP1 = ERKP1 + (PHI(L,KP2)/WT(L))**2
      ERKP1 = ABSH*GSTR(KP1)*SQRT(ERKP1)
C
C   USING ESTIMATED ERROR AT ORDER K+1, DETERMINE APPROPRIATE ORDER
C   FOR NEXT STEP
C
      IF(K .GT. 1) GO TO 445
      IF(ERKP1 .GE. 0.5D0*ERK) GO TO 460
      GO TO 450
 445  IF(ERKM1 .LE. DMIN1(ERK,ERKP1)) GO TO 455
      IF(ERKP1 .GE. ERK  .OR.  K .EQ. 12) GO TO 460
C
C   HERE ERKP1 .LT. ERK .LT. AMAX1(ERKM1,ERKM2) ELSE ORDER WOULD HAVE
C   BEEN LOWERED IN BLOCK 2.  THUS ORDER IS TO BE RAISED
C
C   RAISE ORDER
C
 450  K = KP1
      ERK = ERKP1
      GO TO 460
C
C   LOWER ORDER
C
 455  K = KM1
      ERK = ERKM1
C
C   WITH NEW ORDER DETERMINE APPROPRIATE STEP SIZE FOR NEXT STEP
C
 460  HNEW = H + H
      IF(PHASE1) GO TO 465
      IF(P5EPS .GE. ERK*TWO(K+1)) GO TO 465
      HNEW = H
      IF(P5EPS .GE. ERK) GO TO 465
      TEMP2 = K+1
      R = (P5EPS/ERK)**(1.0D0/TEMP2)
      HNEW = ABSH*DMAX1(0.5D0,DMIN1(0.9D0,R))
      HNEW = DSIGN(DMAX1(HNEW,FOURU*ABS(X)),H)
 465  H = HNEW
      RETURN
C       ***     END BLOCK 4     ***
      END
      SUBROUTINE INTRP(X,Y,XOUT,YOUT,YPOUT,NEQN,KOLD,PHI,PSI)
C
C     SANDIA MATHEMATICAL PROGRAM LIBRARY
C     APPLIED MATHEMATICS DIVISION 2613
C     SANDIA LABORATORIES
C     ALBUQUERQUE, NEW MEXICO  87185
C     CONTROL DATA 6600/7600  VERSION 7.2  MAY 1978
C  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C                    ISSUED BY SANDIA LABORATORIES                     *
C  *                   A PRIME CONTRACTOR TO THE                       *
C  *                UNITED STATES DEPARTMENT OF ENERGY                 *
C  * * * * * * * * * * * * * * * NOTICE  * * * * * * * * * * * * * * * *
C  * THIS REPORT WAS PREPARED AS AN ACCOUNT OF WORK SPONSORED BY THE   *
C  * UNITED STATES GOVERNMENT.  NEITHER THE UNITED STATES NOR THE      *
C  * UNITED STATES DEPARTMENT OF ENERGY NOR ANY OF THEIR EMPLOYEES,    *
C  * NOR ANY OF THEIR CONTRACTORS, SUBCONTRACTORS, OR THEIR EMPLOYEES  *
C  * MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL      *
C  * LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS OR     *
C  * USEFULNESS OF ANY INFORMATION, APPARATUS, PRODUCT OR PROCESS      *
C  * DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE          *
C  * OWNED RIGHTS.                                                     *
C  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C  * THE PRIMARY DOCUMENT FOR THE LIBRARY OF WHICH THIS ROUTINE IS     *
C  * PART IS SAND77-1441.                                              *
C  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C   WRITTEN BY L. F. SHAMPINE AND M. K. GORDON
C
C   ABSTRACT
C
C
C   THE METHODS IN SUBROUTINE  STEP1  APPROXIMATE THE SOLUTION NEAR  X
C   BY A POLYNOMIAL.  SUBROUTINE  INTRP  APPROXIMATES THE SOLUTION AT
C   XOUT  BY EVALUATING THE POLYNOMIAL THERE.  INFORMATION DEFINING THIS
C   POLYNOMIAL IS PASSED FROM  STEP1  SO  INTRP  CANNOT BE USED ALONE.
C
C   THIS CODE IS COMPLETELY EXPLAINED AND DOCUMENTED IN THE TEXT,
C   COMPUTER SOLUTION OF ORDINARY DIFFERENTIAL EQUATIONS, THE INITIAL
C   VALUE PROBLEM  BY L. F. SHAMPINE AND M. K. GORDON.
C   FURTHER DETAILS ON USE OF THIS CODE ARE AVAILABLE IN *SOLVING
C   ORDINARY DIFFERENTIAL EQUATIONS WITH ODE, STEP, AND INTRP*,
C   BY L. F. SHAMPINE AND M. K. GORDON, SLA-73-1060.
C
C   INPUT TO INTRP --
C
C   THE USER PROVIDES STORAGE IN THE CALLING PROGRAM FOR THE ARRAYS IN
C   THE CALL LIST
C      DIMENSION Y(NEQN),YOUT(NEQN),YPOUT(NEQN),PHI(NEQN,16),PSI(12)
C   AND DEFINES
C      XOUT -- POINT AT WHICH SOLUTION IS DESIRED.
C   THE REMAINING PARAMETERS ARE DEFINED IN  STEP1  AND PASSED TO
C   INTRP  FROM THAT SUBROUTINE
C
C   OUTPUT FROM  INTRP --
C
C      YOUT(*) -- SOLUTION AT  XOUT
C      YPOUT(*) -- DERIVATIVE OF SOLUTION AT  XOUT
C   THE REMAINING PARAMETERS ARE RETURNED UNALTERED FROM THEIR INPUT
C   VALUES.  INTEGRATION WITH  STEP1  MAY BE CONTINUED.
C
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION Y(NEQN),YOUT(NEQN),YPOUT(NEQN),PHI(NEQN,16),PSI(12)
      DIMENSION G(13),W(13),RHO(13)
      DATA G(1)/1.0D0/,RHO(1)/1.0D0/
C
      HI = XOUT - X
      KI = KOLD + 1
      KIP1 = KI + 1
C
C   INITIALIZE W(*) FOR COMPUTING G(*)
C
      DO 5 I = 1,KI
        TEMP1 = I
 5      W(I) = 1.0D0/TEMP1
      TERM = 0.0D0
C
C   COMPUTE G(*)
C
      DO 15 J = 2,KI
        JM1 = J - 1
        PSIJM1 = PSI(JM1)
        GAMMA = (HI + TERM)/PSIJM1
        ETA = HI/PSIJM1
        LIMIT1 = KIP1 - J
        DO 10 I = 1,LIMIT1
 10       W(I) = GAMMA*W(I) - ETA*W(I+1)
        G(J) = W(1)
        RHO(J) = GAMMA*RHO(JM1)
 15     TERM = PSIJM1
C
C   INTERPOLATE
C
      DO 20 L = 1,NEQN
        YPOUT(L) = 0.0D0
 20     YOUT(L) = 0.0D0
      DO 30 J = 1,KI
        I = KIP1 - J
        TEMP2 = G(I)
        TEMP3 = RHO(I)
        DO 25 L = 1,NEQN
          YOUT(L) = YOUT(L) + TEMP2*PHI(L,I)
 25       YPOUT(L) = YPOUT(L) + TEMP3*PHI(L,I)
 30     CONTINUE
      DO 35 L = 1,NEQN
 35     YOUT(L) = Y(L) + HI*YOUT(L)
      RETURN
      END
      SUBROUTINE BETA(npts,time,xvolum,yvolum,coef)
c---------------------------------------------------------------
c*    this subroutine calculates the coagulation coefficients
c*    beta, as a function of the volumes of the coagulating p
c*    particles
c*
c*                         Variables
c*
c*    akundx=knudsen number of first particle
c*    akundy=knudsen number of second particle
c*    coef=coagulation coefficient (output array cc/sec
c*    density=particle material density (grams/cc)
c*    difx=diffusivity of first particle (cm**2/sec)
c*    dify=diffusivity of second particle (cm)
c*    dx=diameter of first particle (cm)
c*    dy=diameter of second particle  (cm)
c*    freemn=mean free path of air (centimeters)
c*    npts=number of points (input)
c*    tempk=temperature (degrees kelvin)
c*    time=time (input in seconds)
c*    viscos=viscosity of air (poise)
c*    xvolum=volume of first particle (input in cc)
c*    yvolum=volume of second particle (input array in cc)
c*
c*    expression taken from fuchs, N.A.,1964, pp291-294.D0
c-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION YVOLUM(1),COEF(1)
      COMMON/AERSL1/IPARM(10)
      DATA TEMPK,DENSTY,VISCOS,FREEMN/298.D0,1.D0,1.83D-4,.066D-4/
c
      DX=(1.90986*XVOLUM)**0.33333333333
      AKNUDX=FREEMN*2./DX
      TKV=1.46E-17*TEMPK/VISCOS
      DIFX=(1.+AKNUDX*(1.257+.4*EXP(-1.1/AKNUDX)))*TKV/DX
      SPEEDX=3.51E-16*TEMPK/(XVOLUM*DENSTY)
      PMEANX=2.546479*DIFX/SQRT(SPEEDX)
      GX=DX+PMEANX
      GX1=DX*DX+PMEANX*PMEANX
      GX=(GX*GS*GX-GX1*SQRT(GX1))/(3.*DX*PMEANX)-DX
      GX=GX*GX
C
      DO 10 I=1,NPTS
      DY=(1.90986*YVOLUM(I))**.33333333333
      AKNUDY=FREEMN*2./DY
      DIFY=(1+AKNUDY*(1.257+.4*EXP(-1.1/AKNUDY)))*TKV/DY
      SPEEDY=SQRT(3.51E-16*TEMPK/(YVOLUM(I)*DENSTY))
      SPEED=SQRT(SPEEDX+SPEEDY*SPEEDY)
      PMEANY=2.546479*DIFY/SPEEDY
      GY=DY+PMEANY
      GY1=DY*DY+PMEANY*PMEANY
      GY=(GY*GY*GY-GY1*SQRT(GY1))/(3.*DY*PMEANY)-DY
      G=SQRT(GX+GY*GY)
      COEF(I)=(DX+DY)*.5
      COEF(I)=COEF(I)/(COEF(I)+G)+4.*(DIFX+DIFY)/(SPEED*COEF(I))
   10 COEF(I)=6.2832*(DIFX+DIFY)*(DX+DY)/COEF(I)
      RETURN
C
    1 DO 11 I=1,NPTS
   11 COEF(I)=XVOLUM-YVOLUM(I)
      RETURN
C
    2 DO 12 I=1,NPTS
   12 COEF(I)=0.
      RETURN 
      END
C-----------------------------------------------------------------------
      FUNCTION BOUNDR(TIME)
C-----------------------------------------------------------------------
C*      THIS IS AN EXAMPLE OF A BOUNDARY SOURCE FUNCTION.              *
C*                                                                     *
C*                  VARIABLES                                          *
C*                                                                     *
C*    BOUNDR=SOURCE AT BOUNDARY (PARTICLE VOLUME=VA) (1/CC/SEC/CC/)    *
C*    TOUT(I)=I-TH OUTPUT TIME (SECONDS)                               *
C*    VA=LOWER LIMIT OF CONTINUOUS DISTRIBUTION IN PARTICLE VOLUME (CC)*
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON/AERSL6/TOUT(16),TDUMY,VA,VB,VBOVA,ALGVBA
      BOUNDR=.3
      IF(TIME.GT.TOUT(2)) BOUNDR=BOUNDR*EXP(.0005*(TOUT(2)-TIME))
      RETURN
      END
C-----------------------------------------------------------------------
      SUBROUTINE GROWTH(NPTS,TIME,V,RATE,PARTAL)
C-----------------------------------------------------------------------
C*     THIS IS AN EXAMPLE OF A GROWTH SUBROUTINE USING THE CONTINUUM   *
C*     GROWTH LAW. (REF. GELBARD,F. AND SEINFELD,J.H.,JOURNAL OF       *
C*     colloid AND INTERFACE SCIENCE, VOL.68,PAGES      173-183 (1979))     *
C*                                                                     *
C*                 VARIABLES                                           *
C*                                                                     *
C*    D=PARTICLE DIAMETER  (CM)                                        *
C*    DIFUS=MOLECULAR DIFFUSIVITY  (CM**2/SECOND)                      *
C*    DEL=CONCENTRATION DIFFERENCE  (1/CC)                             *
C*    NPTS=NUMBER OF POINTS  (INPUT)                                   *
C*    PARTAL=PARTIAL OF RATE W.R.T. PARTICLE VOLUME (OUTPUT IN 1/SEC)  *
C*    RATE=GROWTH RATE OF A PARTICLE OF VOLUME V (OUTPUT IN CC/SEC)    *
C*    V=PARTICLE VOLUME (INPUT IN CC)                                  *
C*    VMOLEC=MOLECULAR VOLUME  (CC)                                    *
C-----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION V(1),RATE(1),PARTAL(1)
      COMMON/AERSL1/IPARM(10)
      DATA PI,DIFUS,VMOLEC/3.14159,.1,6.54E-23/
      DEL=1.E8*EXP(-.001*TIME)
      DO I I=1,NPTS
      D=(1.9099*V(I))**.33333333333
      RATE(I)=2.*PI*D*DIFUS*DEL*VMOLEC
      PARTAL(I)=RATE(I)/(3.*V(I))
    1 IF(IPARAM(3).EQ.1) RATE(I)=-2.*RATE(I)
      RETURN
      END DO
C-----------------------------------------------------------------------
      SUBROUTINE XINTL(NPTS,V,DISTB)
C-----------------------------------------------------------------------
c*      this is an example of an initial distribution function.
c*      A sum of three log-normal functions or a logarithmic
c*      interpolation between data points can be used depending
c*      on iparm(2)
c*
c*                        variables
c*      distb=output array of initial distributions (no./cc/cc)
c*      npts=number of points (input)
c*      v=input array of particle volumes (cc)
c*-------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION X(30),F(30),V(1),DISTB(1)
      COMMON/AERSL1/IPARM(10)
C      DIMENSION DP(19),F(19)
C      DATA DP/.0133,.0237,.0421,.075,.133,.237,.42,.513,.61,.704,.784,
C     $ .847,.902,.953,1.01,1.07,1.16,1.28,1.41/
C      DATA F/2.38E7,5.68E6,2.76E5,1.7E5,3.54E4,2.1E3,1.9E2,70.7,24.8,
C     $ 13.9,10.5,7.78,5.9,4.57,3.22,2.36,1.58,.714,.705/
C      DATA ICALL/0/

C      ALNORM(TOT,GMEAN,GLSIG,VX)=.3989*TOT*EXP(-.5*(ALOG(VX/GMEAN)/
C     $ GLSIG)**2)/(VX*GLSIG)

C      IF(IPARM(2).EQ.1) GO TO 2
C      DO 11 I=1,NPTS
C  11  DISTB(I)=ALNORM(1.06E5,1.44E-18,1.76,V(I))+
C     $ ALNORM(3.2E4,8.24E-17,2.31,V(I))+ALNORM(5.4,3.33E-13,2.38,V(I))
C      RETURN
C
C   2  IF(ICALL.EQ.1) GO TO 22
C      ICALL=1
C      DO 23 I=1,19
C      DP(I)=ALOG(F(I))
C  23  F(I)=ALOG(F(I))
C  22  DO 3 NP=1,NPTS
C      D=(6.E12*V(NP)/3.14159)**(.33333333333)
C      DL=ALOG(D)
C      DO 24 I=2,19
C      IF(DL.LT.DP(I)) GO TO 25
C  24  CONTINUE
C  25  DL=E(I)+(DP(I)-DL)/(DP(I)-DP(I-1))*(F(I-1)-F(I))
C   3  DISTB(NP)= EXP(DL)*D/(3.*V(NP))
C      RETURN 
      END
